import {
  usePubNub
} from "./chunk-LS64MTRO.js";
import {
  require_react
} from "./chunk-PKEFF2V6.js";
import {
  __toModule
} from "./chunk-ESTXZSVW.js";

// node_modules/@pubnub/react-chat-components/dist/index.es.js
var React = __toModule(require_react());
var import_react = __toModule(require_react());
function isFileMessage(message) {
  return message.file !== void 0;
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || from);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base) {
      return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var jotai = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it)
      return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var hasInitialValue = function hasInitialValue2(atom2) {
    return "init" in atom2;
  };
  var IS_EQUAL_PROMISE = Symbol();
  var INTERRUPT_PROMISE = Symbol();
  var isInterruptablePromise = function isInterruptablePromise2(promise) {
    return !!promise[INTERRUPT_PROMISE];
  };
  var createInterruptablePromise = function createInterruptablePromise2(promise) {
    var interrupt;
    var interruptablePromise = new Promise(function(resolve, reject) {
      interrupt = resolve;
      promise.then(resolve, reject);
    });
    interruptablePromise[IS_EQUAL_PROMISE] = function(p) {
      return p === interruptablePromise || p === promise;
    };
    interruptablePromise[INTERRUPT_PROMISE] = interrupt;
    return interruptablePromise;
  };
  var GET_VERSION$1 = "v";
  var READ_ATOM = "r";
  var WRITE_ATOM = "w";
  var FLUSH_PENDING = "f";
  var SUBSCRIBE_ATOM = "s";
  var RESTORE_ATOMS = "h";
  var DEV_GET_ATOM_STATE = "a";
  var DEV_GET_MOUNTED = "m";
  var createStore = function createStore2(initialValues, stateListener) {
    var _ref4;
    var version = 0;
    var atomStateMap = new WeakMap();
    var mountedMap = new WeakMap();
    var pendingMap = new Map();
    if (initialValues) {
      for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done; ) {
        var _step$value = _step.value, atom2 = _step$value[0], value = _step$value[1];
        var atomState = {
          v: value,
          r: 0,
          d: new Map()
        };
        if (typeof process === "object" && true) {
          Object.freeze(atomState);
          if (!hasInitialValue(atom2)) {
            console.warn("Found initial value for derived atom which can cause unexpected behavior", atom2);
          }
        }
        atomStateMap.set(atom2, atomState);
      }
    }
    var getAtomState = function getAtomState2(atom3) {
      return atomStateMap.get(atom3);
    };
    var wipAtomState = function wipAtomState2(atom3, dependencies) {
      var atomState2 = getAtomState(atom3);
      var nextAtomState = _extends2({
        r: 0
      }, atomState2, {
        d: dependencies ? new Map(Array.from(dependencies).map(function(a) {
          var _getAtomState$r, _getAtomState;
          return [a, (_getAtomState$r = (_getAtomState = getAtomState(a)) == null ? void 0 : _getAtomState.r) != null ? _getAtomState$r : 0];
        })) : (atomState2 == null ? void 0 : atomState2.d) || new Map()
      });
      return [nextAtomState, (atomState2 == null ? void 0 : atomState2.d) || new Map()];
    };
    var setAtomValue = function setAtomValue2(atom3, value2, dependencies, promise) {
      var _atomState$p;
      var _wipAtomState = wipAtomState(atom3, dependencies), atomState2 = _wipAtomState[0], prevDependencies = _wipAtomState[1];
      if (promise && !((_atomState$p = atomState2.p) != null && _atomState$p[IS_EQUAL_PROMISE](promise))) {
        return;
      }
      atomState2.c == null ? void 0 : atomState2.c();
      delete atomState2.e;
      delete atomState2.p;
      delete atomState2.c;
      delete atomState2.i;
      if (!("v" in atomState2) || !Object.is(atomState2.v, value2)) {
        atomState2.v = value2;
        ++atomState2.r;
      }
      commitAtomState(atom3, atomState2, dependencies && prevDependencies);
    };
    var setAtomReadError = function setAtomReadError2(atom3, error, dependencies, promise) {
      var _atomState$p2;
      var _wipAtomState2 = wipAtomState(atom3, dependencies), atomState2 = _wipAtomState2[0], prevDependencies = _wipAtomState2[1];
      if (promise && !((_atomState$p2 = atomState2.p) != null && _atomState$p2[IS_EQUAL_PROMISE](promise))) {
        return;
      }
      atomState2.c == null ? void 0 : atomState2.c();
      delete atomState2.p;
      delete atomState2.c;
      delete atomState2.i;
      atomState2.e = error;
      commitAtomState(atom3, atomState2, prevDependencies);
    };
    var setAtomReadPromise = function setAtomReadPromise2(atom3, promise, dependencies) {
      var _atomState$p3;
      var _wipAtomState3 = wipAtomState(atom3, dependencies), atomState2 = _wipAtomState3[0], prevDependencies = _wipAtomState3[1];
      if ((_atomState$p3 = atomState2.p) != null && _atomState$p3[IS_EQUAL_PROMISE](promise)) {
        return;
      }
      atomState2.c == null ? void 0 : atomState2.c();
      if (isInterruptablePromise(promise)) {
        atomState2.p = promise;
        delete atomState2.c;
      } else {
        var interruptablePromise = createInterruptablePromise(promise);
        atomState2.p = interruptablePromise;
        atomState2.c = interruptablePromise[INTERRUPT_PROMISE];
      }
      commitAtomState(atom3, atomState2, prevDependencies);
    };
    var setAtomInvalidated = function setAtomInvalidated2(atom3) {
      var _wipAtomState4 = wipAtomState(atom3), atomState2 = _wipAtomState4[0];
      atomState2.i = atomState2.r;
      commitAtomState(atom3, atomState2);
    };
    var setAtomWritePromise = function setAtomWritePromise2(atom3, promise) {
      var _wipAtomState5 = wipAtomState(atom3), atomState2 = _wipAtomState5[0];
      if (promise) {
        atomState2.w = promise;
      } else {
        delete atomState2.w;
      }
      commitAtomState(atom3, atomState2);
    };
    var scheduleReadAtomState = function scheduleReadAtomState2(atom3, promise) {
      promise.finally(function() {
        readAtomState(atom3, true);
      });
    };
    var readAtomState = function readAtomState2(atom3, force) {
      if (!force) {
        var _atomState = getAtomState(atom3);
        if (_atomState) {
          _atomState.d.forEach(function(_, a) {
            if (a !== atom3) {
              var aState = getAtomState(a);
              if (aState && !aState.e && !aState.p && aState.r === aState.i) {
                readAtomState2(a, true);
              }
            }
          });
          if (Array.from(_atomState.d.entries()).every(function(_ref) {
            var a = _ref[0], r = _ref[1];
            var aState = getAtomState(a);
            return aState && !aState.e && !aState.p && aState.r !== aState.i && aState.r === r;
          })) {
            return _atomState;
          }
        }
      }
      var error;
      var promise;
      var value2;
      var dependencies = new Set();
      try {
        var promiseOrValue = atom3.read(function(a) {
          dependencies.add(a);
          var aState = a === atom3 ? getAtomState(a) : readAtomState2(a);
          if (aState) {
            if (aState.e) {
              throw aState.e;
            }
            if (aState.p) {
              throw aState.p;
            }
            return aState.v;
          }
          if (hasInitialValue(a)) {
            return a.init;
          }
          throw new Error("no atom init");
        });
        if (promiseOrValue instanceof Promise) {
          promise = promiseOrValue.then(function(value3) {
            setAtomValue(atom3, value3, dependencies, promise);
            flushPending();
          }).catch(function(e) {
            if (e instanceof Promise) {
              scheduleReadAtomState(atom3, e);
              return e;
            }
            setAtomReadError(atom3, e instanceof Error ? e : new Error(e), dependencies, promise);
            flushPending();
          });
        } else {
          value2 = promiseOrValue;
        }
      } catch (errorOrPromise) {
        if (errorOrPromise instanceof Promise) {
          promise = errorOrPromise;
        } else if (errorOrPromise instanceof Error) {
          error = errorOrPromise;
        } else {
          error = new Error(errorOrPromise);
        }
      }
      if (error) {
        setAtomReadError(atom3, error, dependencies);
      } else if (promise) {
        setAtomReadPromise(atom3, promise, dependencies);
      } else {
        setAtomValue(atom3, value2, dependencies);
      }
      return getAtomState(atom3);
    };
    var readAtom = function readAtom2(readingAtom) {
      var atomState2 = readAtomState(readingAtom);
      return atomState2;
    };
    var addAtom = function addAtom2(addingAtom) {
      var mounted = mountedMap.get(addingAtom);
      if (!mounted) {
        mounted = mountAtom(addingAtom);
      }
      flushPending();
      return mounted;
    };
    var canUnmountAtom = function canUnmountAtom2(atom3, mounted) {
      return !mounted.l.size && (!mounted.d.size || mounted.d.size === 1 && mounted.d.has(atom3));
    };
    var delAtom = function delAtom2(deletingAtom) {
      var mounted = mountedMap.get(deletingAtom);
      if (mounted && canUnmountAtom(deletingAtom, mounted)) {
        unmountAtom(deletingAtom);
      }
      flushPending();
    };
    var invalidateDependents = function invalidateDependents2(atom3) {
      var mounted = mountedMap.get(atom3);
      mounted == null ? void 0 : mounted.d.forEach(function(dependent) {
        if (dependent === atom3) {
          return;
        }
        setAtomInvalidated(dependent);
        invalidateDependents2(dependent);
      });
    };
    var writeAtomState = function writeAtomState2(atom3, update) {
      var _getAtomState2;
      var writePromise = (_getAtomState2 = getAtomState(atom3)) == null ? void 0 : _getAtomState2.w;
      if (writePromise) {
        writePromise.then(function() {
          writeAtomState2(atom3, update);
          flushPending();
        });
        return;
      }
      var writeGetter = function writeGetter2(a, unstable_promise) {
        if (unstable_promise === void 0) {
          unstable_promise = false;
        }
        var aState = readAtomState(a);
        if (aState.e) {
          throw aState.e;
        }
        if (aState.p) {
          if (typeof process === "object" && true) {
            if (unstable_promise) {
              console.info("promise option in getter is an experimental feature.", a);
            } else {
              console.warn("Reading pending atom state in write operation. We throw a promise for now.", a);
            }
          }
          if (unstable_promise) {
            return aState.p.then(function() {
              return writeGetter2(a, unstable_promise);
            });
          }
          throw aState.p;
        }
        if ("v" in aState) {
          return aState.v;
        }
        if (typeof process === "object" && true) {
          console.warn("[Bug] no value found while reading atom in write operation. This is probably a bug.", a);
        }
        throw new Error("no value found");
      };
      var promiseOrVoid = atom3.write(writeGetter, function(a, v) {
        if (a === atom3) {
          if (!hasInitialValue(a)) {
            throw new Error("no atom init");
          }
          if (v instanceof Promise) {
            var promise2 = v.then(function(resolvedValue) {
              setAtomValue(a, resolvedValue);
              invalidateDependents(a);
              flushPending();
            }).catch(function(e) {
              setAtomReadError(atom3, e instanceof Error ? e : new Error(e));
              flushPending();
            });
            setAtomReadPromise(atom3, promise2);
          } else {
            setAtomValue(a, v);
          }
          invalidateDependents(a);
        } else {
          writeAtomState2(a, v);
        }
        flushPending();
      }, update);
      if (promiseOrVoid instanceof Promise) {
        var promise = promiseOrVoid.finally(function() {
          setAtomWritePromise(atom3);
          flushPending();
        });
        setAtomWritePromise(atom3, promise);
      }
    };
    var writeAtom = function writeAtom2(writingAtom, update) {
      writeAtomState(writingAtom, update);
      flushPending();
    };
    var isActuallyWritableAtom = function isActuallyWritableAtom2(atom3) {
      return !!atom3.write;
    };
    var mountAtom = function mountAtom2(atom3, initialDependent) {
      var atomState2 = readAtomState(atom3);
      atomState2.d.forEach(function(_, a) {
        if (a !== atom3) {
          var aMounted = mountedMap.get(a);
          if (aMounted) {
            aMounted.d.add(atom3);
          } else {
            mountAtom2(a, atom3);
          }
        }
      });
      var mounted = {
        d: new Set(initialDependent && [initialDependent]),
        l: new Set(),
        u: void 0
      };
      mountedMap.set(atom3, mounted);
      if (isActuallyWritableAtom(atom3) && atom3.onMount) {
        var setAtom = function setAtom2(update) {
          return writeAtom(atom3, update);
        };
        mounted.u = atom3.onMount(setAtom);
      }
      return mounted;
    };
    var unmountAtom = function unmountAtom2(atom3) {
      var _mountedMap$get;
      var onUnmount = (_mountedMap$get = mountedMap.get(atom3)) == null ? void 0 : _mountedMap$get.u;
      if (onUnmount) {
        onUnmount();
      }
      mountedMap.delete(atom3);
      var atomState2 = getAtomState(atom3);
      if (atomState2) {
        atomState2.d.forEach(function(_, a) {
          if (a !== atom3) {
            var mounted = mountedMap.get(a);
            if (mounted) {
              mounted.d.delete(atom3);
              if (canUnmountAtom(a, mounted)) {
                unmountAtom2(a);
              }
            }
          }
        });
      } else if (typeof process === "object" && true) {
        console.warn("[Bug] could not find atom state to unmount", atom3);
      }
    };
    var mountDependencies = function mountDependencies2(atom3, atomState2, prevDependencies) {
      var dependencies = new Set(atomState2.d.keys());
      prevDependencies.forEach(function(_, a) {
        if (dependencies.has(a)) {
          dependencies.delete(a);
          return;
        }
        var mounted = mountedMap.get(a);
        if (mounted) {
          mounted.d.delete(atom3);
          if (canUnmountAtom(a, mounted)) {
            unmountAtom(a);
          }
        }
      });
      dependencies.forEach(function(a) {
        var mounted = mountedMap.get(a);
        if (mounted) {
          var dependents = mounted.d;
          dependents.add(atom3);
        } else {
          mountAtom(a, atom3);
        }
      });
    };
    var commitAtomState = function commitAtomState2(atom3, atomState2, prevDependencies) {
      if (typeof process === "object" && true) {
        Object.freeze(atomState2);
      }
      var isNewAtom = !atomStateMap.has(atom3);
      atomStateMap.set(atom3, atomState2);
      if (stateListener) {
        stateListener(atom3, isNewAtom);
      }
      ++version;
      if (!pendingMap.has(atom3)) {
        pendingMap.set(atom3, prevDependencies);
      }
    };
    var flushPending = function flushPending2() {
      var pending = Array.from(pendingMap);
      pendingMap.clear();
      pending.forEach(function(_ref2) {
        var atom3 = _ref2[0], prevDependencies = _ref2[1];
        var atomState2 = getAtomState(atom3);
        if (atomState2) {
          if (prevDependencies) {
            mountDependencies(atom3, atomState2, prevDependencies);
          }
        } else if (typeof process === "object" && true) {
          console.warn("[Bug] atom state not found in flush", atom3);
        }
        var mounted = mountedMap.get(atom3);
        mounted == null ? void 0 : mounted.l.forEach(function(listener) {
          return listener();
        });
      });
    };
    var subscribeAtom = function subscribeAtom2(atom3, callback) {
      var mounted = addAtom(atom3);
      var listeners = mounted.l;
      listeners.add(callback);
      return function() {
        listeners.delete(callback);
        delAtom(atom3);
      };
    };
    var restoreAtoms = function restoreAtoms2(values) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done; ) {
        var _step2$value = _step2.value, _atom = _step2$value[0], _value = _step2$value[1];
        if (hasInitialValue(_atom)) {
          setAtomValue(_atom, _value);
          invalidateDependents(_atom);
        }
      }
      flushPending();
    };
    if (typeof process === "object" && true) {
      var _ref3;
      return _ref3 = {}, _ref3[GET_VERSION$1] = function() {
        return version;
      }, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[FLUSH_PENDING] = flushPending, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_GET_ATOM_STATE] = function(a) {
        return atomStateMap.get(a);
      }, _ref3[DEV_GET_MOUNTED] = function(a) {
        return mountedMap.get(a);
      }, _ref3;
    }
    return _ref4 = {}, _ref4[GET_VERSION$1] = function() {
      return version;
    }, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[FLUSH_PENDING] = flushPending, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;
  };
  var TARGET = "_uMS_T";
  var GET_VERSION = "_uMS_V";
  var createMutableSource = function createMutableSource2(target, getVersion) {
    var _ref;
    return _ref = {}, _ref[TARGET] = target, _ref[GET_VERSION] = getVersion, _ref;
  };
  var useMutableSource = function useMutableSource2(source, getSnapshot, subscribe) {
    var lastVersion = import_react.default.useRef();
    var currentVersion = source[GET_VERSION](source[TARGET]);
    var _useState = import_react.default.useState(function() {
      return [source, getSnapshot, subscribe, currentVersion, getSnapshot(source[TARGET])];
    }), state = _useState[0], setState = _useState[1];
    var currentSnapshot = state[4];
    if (state[0] !== source || state[1] !== getSnapshot || state[2] !== subscribe) {
      currentSnapshot = getSnapshot(source[TARGET]);
      setState([source, getSnapshot, subscribe, currentVersion, currentSnapshot]);
    } else if (currentVersion !== state[3] && currentVersion !== lastVersion.current) {
      currentSnapshot = getSnapshot(source[TARGET]);
      if (!Object.is(currentSnapshot, state[4])) {
        setState([source, getSnapshot, subscribe, currentVersion, currentSnapshot]);
      }
    }
    import_react.default.useEffect(function() {
      var didUnsubscribe = false;
      var checkForUpdates = function checkForUpdates2() {
        if (didUnsubscribe) {
          return;
        }
        try {
          var nextSnapshot = getSnapshot(source[TARGET]);
          var nextVersion = source[GET_VERSION](source[TARGET]);
          lastVersion.current = nextVersion;
          setState(function(prev) {
            if (prev[0] !== source || prev[1] !== getSnapshot || prev[2] !== subscribe) {
              return prev;
            }
            if (Object.is(prev[4], nextSnapshot)) {
              return prev;
            }
            return [prev[0], prev[1], prev[2], nextVersion, nextSnapshot];
          });
        } catch (e) {
          setState(function(prev) {
            return [].concat(prev);
          });
        }
      };
      var unsubscribe = subscribe(source[TARGET], checkForUpdates);
      checkForUpdates();
      return function() {
        didUnsubscribe = true;
        unsubscribe();
      };
    }, [source, getSnapshot, subscribe]);
    return currentSnapshot;
  };
  var createScopeContainerForProduction = function createScopeContainerForProduction2(initialValues) {
    var store = createStore(initialValues);
    var mutableSource = createMutableSource(store, store[GET_VERSION$1]);
    return [store, mutableSource];
  };
  var createScopeContainerForDevelopment = function createScopeContainerForDevelopment2(initialValues) {
    var devVersion = 0;
    var devListeners = new Set();
    var devContainer = {
      atoms: Array.from(initialValues != null ? initialValues : []).map(function(_ref) {
        var a = _ref[0];
        return a;
      })
    };
    var stateListener = function stateListener2(updatedAtom, isNewAtom) {
      ++devVersion;
      if (isNewAtom) {
        devContainer.atoms = [].concat(devContainer.atoms, [updatedAtom]);
      }
      Promise.resolve().then(function() {
        devListeners.forEach(function(listener) {
          return listener();
        });
      });
    };
    var store = createStore(initialValues, stateListener);
    var mutableSource = createMutableSource(store, store[GET_VERSION$1]);
    var devMutableSource = createMutableSource(devContainer, function() {
      return devVersion;
    });
    var devSubscribe = function devSubscribe2(_, callback) {
      devListeners.add(callback);
      return function() {
        return devListeners.delete(callback);
      };
    };
    return [store, mutableSource, devMutableSource, devSubscribe];
  };
  var isDevScopeContainer = function isDevScopeContainer2(scopeContainer) {
    return scopeContainer.length > 2;
  };
  var createScopeContainer = typeof process === "object" && true ? createScopeContainerForDevelopment : createScopeContainerForProduction;
  var ScopeContextMap = new Map();
  var getScopeContext = function getScopeContext2(scope) {
    if (!ScopeContextMap.has(scope)) {
      ScopeContextMap.set(scope, import_react.default.createContext(createScopeContainer()));
    }
    return ScopeContextMap.get(scope);
  };
  var Provider = function Provider2(_ref) {
    var initialValues = _ref.initialValues, scope = _ref.scope, children = _ref.children;
    var scopeContainerRef = import_react.default.useRef();
    if (!scopeContainerRef.current) {
      scopeContainerRef.current = createScopeContainer(initialValues);
    }
    if (typeof process === "object" && true && true && isDevScopeContainer(scopeContainerRef.current)) {
      useDebugState(scopeContainerRef.current);
    }
    var ScopeContainerContext = getScopeContext(scope);
    return import_react.default.createElement(ScopeContainerContext.Provider, {
      value: scopeContainerRef.current
    }, children);
  };
  var atomToPrintable = function atomToPrintable2(atom2) {
    return atom2.debugLabel || atom2.toString();
  };
  var stateToPrintable = function stateToPrintable2(_ref2) {
    var store = _ref2[0], atoms = _ref2[1];
    return Object.fromEntries(atoms.flatMap(function(atom2) {
      var _store$DEV_GET_MOUNTE, _store$DEV_GET_ATOM_S;
      var mounted = (_store$DEV_GET_MOUNTE = store[DEV_GET_MOUNTED]) == null ? void 0 : _store$DEV_GET_MOUNTE.call(store, atom2);
      if (!mounted) {
        return [];
      }
      var dependents = mounted.d;
      var atomState = ((_store$DEV_GET_ATOM_S = store[DEV_GET_ATOM_STATE]) == null ? void 0 : _store$DEV_GET_ATOM_S.call(store, atom2)) || {};
      return [[atomToPrintable(atom2), {
        value: atomState.e || atomState.p || atomState.w || atomState.v,
        dependents: Array.from(dependents).map(atomToPrintable)
      }]];
    }));
  };
  var useDebugState = function useDebugState2(scopeContainer) {
    var store = scopeContainer[0], devMutableSource = scopeContainer[2], devSubscribe = scopeContainer[3];
    var atoms = useMutableSource(devMutableSource, import_react.default.useCallback(function(devContainer) {
      return devContainer.atoms;
    }, []), devSubscribe);
    import_react.default.useDebugValue([store, atoms], stateToPrintable);
  };
  var keyCount = 0;
  function atom(read, write) {
    var key = "atom" + ++keyCount;
    var config = {
      toString: function toString2() {
        return key;
      }
    };
    if (typeof read === "function") {
      config.read = read;
    } else {
      config.init = read;
      config.read = function(get) {
        return get(config);
      };
      config.write = function(get, set2, update) {
        set2(config, typeof update === "function" ? update(get(config)) : update);
      };
    }
    if (write) {
      config.write = write;
    }
    return config;
  }
  var isWritable = function isWritable2(atom2) {
    return !!atom2.write;
  };
  function useAtom(atom2, scope) {
    var getAtomValue = import_react.default.useCallback(function(store2) {
      var atomState = store2[READ_ATOM](atom2);
      if (atomState.e) {
        throw atomState.e;
      }
      if (atomState.p) {
        throw atomState.p;
      }
      if (atomState.w) {
        throw atomState.w;
      }
      if ("v" in atomState) {
        return atomState.v;
      }
      throw new Error("no atom value");
    }, [atom2]);
    var subscribe = import_react.default.useCallback(function(store2, callback) {
      return store2[SUBSCRIBE_ATOM](atom2, callback);
    }, [atom2]);
    if ("scope" in atom2) {
      console.warn("atom.scope is deprecated. Please do useAtom(atom, scope) instead.");
      scope = atom2.scope;
    }
    var ScopeContext = getScopeContext(scope);
    var _useContext = import_react.default.useContext(ScopeContext), store = _useContext[0], mutableSource = _useContext[1];
    var value = useMutableSource(mutableSource, getAtomValue, subscribe);
    import_react.default.useEffect(function() {
      store[FLUSH_PENDING]();
    });
    var setAtom = import_react.default.useCallback(function(update) {
      if (isWritable(atom2)) {
        store[WRITE_ATOM](atom2, update);
      } else {
        throw new Error("not writable atom");
      }
    }, [store, atom2]);
    import_react.default.useDebugValue(value);
    return [value, setAtom];
  }
  exports.Provider = Provider;
  exports.SECRET_INTERNAL_getScopeContext = getScopeContext;
  exports.SECRET_INTERNAL_useMutableSource = useMutableSource;
  exports.atom = atom;
  exports.useAtom = useAtom;
});
var lodash_clonedeep = createCommonjsModule(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag2] = cloneableTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map, pair) {
    map.set(pair[0], pair[1]);
    return map;
  }
  function addSetEntry(set2, value) {
    set2.add(value);
    return set2;
  }
  function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject2(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectToString2 = objectProto2.toString;
  var reIsNative2 = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array = root2.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString = toSource2(DataView), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set2), weakMapCtorString = toSource2(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash2(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
  }
  function hashDelete2(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    return getMapData2(this, key)["delete"](key);
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    getMapData2(this, key).set(key, value);
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack(entries) {
    this.__data__ = new ListCache2(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache2();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache2) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache2(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue2(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag2 || tag == genTag2;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        if (isHostObject2(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue2(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result;
  }
  function baseCreate(proto) {
    return isObject2(proto) ? objectCreate(proto) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString2.call(value);
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor());
  }
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array, addSetEntry, new set2.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      assignValue2(object, key, newValue === void 0 ? source[key] : newValue);
    }
    return object;
  }
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData2(map, key) {
    var data = map.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString2.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag2:
        return cloneSymbol(object);
    }
  }
  function isIndex2(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString2.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString2.call(value) : "";
    return tag == funcTag2 || tag == genTag2;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return !!value && typeof value == "object";
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = cloneDeep;
});
var FUNC_ERROR_TEXT = "Expected a function";
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var INFINITY = 1 / 0;
var MAX_SAFE_INTEGER = 9007199254740991;
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var symbolTag = "[object Symbol]";
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var reLeadingDot = /^\./;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
var arrayProto = Array.prototype;
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
var Symbol$1 = root.Symbol;
var splice = arrayProto.splice;
var Map$1 = getNative(root, "Map");
var nativeCreate = getNative(Object, "create");
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function Hash(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key)["delete"](key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    object[key] = value;
  }
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = isKey(path, object) ? [path] : castPath(path);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey(path[index]), newValue = value;
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var stringToPath = memoize(function(string) {
  string = toString(string);
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, string2) {
    result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
function memoize(func, resolver) {
  if (typeof func != "function" || resolver && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var isArray = Array.isArray;
function isFunction(value) {
  var tag = isObject(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isObject(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}
var lodash_set = set;
var ThemeAtom = jotai.atom("light");
var CurrentChannelAtom = jotai.atom("");
var SubscribeChannelsAtom = jotai.atom([]);
var SubscribeChannelGroupsAtom = jotai.atom([]);
var UsersMetaAtom = jotai.atom([]);
var MessagesAtom = jotai.atom({});
var PaginationAtom = jotai.atom({});
var TypingIndicatorAtom = jotai.atom({});
var TypingIndicatorTimeoutAtom = jotai.atom(10);
var RetryFunctionAtom = jotai.atom({
  function: function() {
    return null;
  }
});
var ErrorFunctionAtom = jotai.atom({
  function: function() {
    return null;
  }
});
var CurrentChannelMessagesAtom = jotai.atom(function(get) {
  return get(MessagesAtom) ? get(MessagesAtom)[get(CurrentChannelAtom)] || [] : [];
}, function(get, set2, value) {
  var _a;
  return set2(MessagesAtom, Object.assign({}, get(MessagesAtom), (_a = {}, _a[get(CurrentChannelAtom)] = value, _a)));
});
var CurrentChannelPaginationAtom = jotai.atom(function(get) {
  return get(PaginationAtom)[get(CurrentChannelAtom)] || false;
}, function(get, set2, value) {
  var _a;
  return set2(PaginationAtom, Object.assign({}, get(PaginationAtom), (_a = {}, _a[get(CurrentChannelAtom)] = value, _a)));
});
var CurrentChannelTypingIndicatorAtom = jotai.atom(function(get) {
  return get(TypingIndicatorAtom)[get(CurrentChannelAtom)] || {};
}, function(get, set2, value) {
  var _a;
  return set2(TypingIndicatorAtom, Object.assign({}, get(TypingIndicatorAtom), (_a = {}, _a[get(CurrentChannelAtom)] = value, _a)));
});
function styleInject(css, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z$5 = "/*\n* Global color variables for light and dark theme\n* Warning! When hexToRGB is used on a color, the variable can only be used with rgba color function\n* inside of the actual CSS. To goal of this is to introduce alpha channels on some of the colors\n*/\n:root {\n  --chat--light__background--1: #f0f3f7;\n  --chat--light__background--2: #ffffff;\n  --chat--light__background--3: #eaeef3;\n  --chat--light__background--4: #01bd4c;\n  --chat--light__background--5-rgb: 239, 58, 67;\n  --chat--light__color--1: #585858;\n  --chat--light__color--2: #999999;\n  --chat--light__color--2-rgb: 153, 153, 153;\n  --chat--light__border--1: #ced6e0;\n  --chat--light__border--2: #bcc6d1;\n  --chat--light__hover--1: #de2440;\n  --chat--light__hover--2: #e4e9f0;\n  --chat--light__hover--3: #e9eef4;\n  --chat--light__hover--4: #e1e8f0;\n  --chat--dark__background--1: #1c1c28;\n  --chat--dark__background--2: #2a2a39;\n  --chat--dark__background--2-rgb: 42, 42, 57;\n  --chat--dark__background--4: #01bd4c;\n  --chat--dark__background--5: 239, 58, 67;\n  --chat--dark__color--1: rgba(228, 228, 235, 0.8);\n  --chat--dark__color--2: #999999;\n  --chat--dark__border--1: #28293d;\n  --chat--dark__hover--1: #de2440;\n  --chat--dark__hover--2: #232333;\n  --chat--dark__hover--4: #555770;\n  --chat--dark__hover--4-rgb: 85, 87, 112;\n}";
styleInject(css_248z$5);
var Chat = function(_super) {
  __extends(Chat2, _super);
  function Chat2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = { error: null };
    return _this;
  }
  Chat2.getDerivedStateFromError = function(error) {
    return { error };
  };
  Chat2.prototype.componentDidCatch = function(error) {
    if (this.props.onError)
      this.props.onError(error);
  };
  Chat2.prototype.render = function() {
    return import_react.default.createElement(jotai.Provider, null, import_react.default.createElement(ChatInternal, __assign({}, this.props)));
  };
  Chat2.defaultProps = {
    channels: [],
    channelGroups: [],
    theme: "light",
    enablePresence: true,
    typingIndicatorTimeout: 10,
    users: [],
    retryOptions: {
      maxRetries: 1,
      timeout: 0,
      exponentialFactor: 1
    },
    onError: function() {
      return null;
    }
  };
  return Chat2;
}(import_react.Component);
var ChatInternal = function(props) {
  var pubnub = usePubNub();
  var _a = jotai.useAtom(MessagesAtom), setMessages = _a[1];
  var _b = jotai.useAtom(ThemeAtom), setTheme = _b[1];
  var _c = jotai.useAtom(ErrorFunctionAtom), setErrorFunction = _c[1];
  var _d = jotai.useAtom(RetryFunctionAtom), setRetryFunction = _d[1];
  var _e = jotai.useAtom(TypingIndicatorAtom), setTypingIndicator = _e[1];
  var _f = jotai.useAtom(TypingIndicatorTimeoutAtom), setTypingIndicatorTimeout = _f[1];
  var _g = jotai.useAtom(UsersMetaAtom), setUsersMeta = _g[1];
  var _h = jotai.useAtom(CurrentChannelAtom), currentChannel = _h[0], setCurrentChannel = _h[1];
  var _j = jotai.useAtom(SubscribeChannelsAtom), channels = _j[0], setChannels = _j[1];
  var _k = jotai.useAtom(SubscribeChannelGroupsAtom), channelGroups = _k[0], setChannelGroups = _k[1];
  var retryOnError = (0, import_react.useCallback)(function(fn) {
    return __awaiter(void 0, void 0, void 0, function() {
      var _a2, maxRetries, timeout, exponentialFactor, _loop_1, i, state_1;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            _a2 = props.retryOptions, maxRetries = _a2.maxRetries, timeout = _a2.timeout, exponentialFactor = _a2.exponentialFactor;
            _loop_1 = function(i2) {
              var _c2, error_1;
              return __generator(this, function(_d2) {
                switch (_d2.label) {
                  case 0:
                    _d2.trys.push([0, 2, , 4]);
                    _c2 = {};
                    return [4, fn()];
                  case 1:
                    return [2, (_c2.value = _d2.sent(), _c2)];
                  case 2:
                    error_1 = _d2.sent();
                    if (maxRetries === i2 + 1)
                      throw error_1;
                    return [4, new Promise(function(resolve) {
                      return setTimeout(resolve, timeout * Math.pow(exponentialFactor, i2));
                    })];
                  case 3:
                    _d2.sent();
                    return [3, 4];
                  case 4:
                    return [2];
                }
              });
            };
            i = 0;
            _b2.label = 1;
          case 1:
            if (!(i < maxRetries))
              return [3, 4];
            return [5, _loop_1(i)];
          case 2:
            state_1 = _b2.sent();
            if (typeof state_1 === "object")
              return [2, state_1.value];
            _b2.label = 3;
          case 3:
            i++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  }, [props.retryOptions]);
  (0, import_react.useEffect)(function() {
    pubnub._config._addPnsdkSuffix("chat-components", "RCC/0.7.0");
  }, []);
  (0, import_react.useEffect)(function() {
    setTypingIndicatorTimeout(props.typingIndicatorTimeout);
  }, []);
  (0, import_react.useEffect)(function() {
    setUsersMeta(props.users);
  }, [props.users]);
  (0, import_react.useEffect)(function() {
    setTheme(props.theme);
  }, [props.theme]);
  (0, import_react.useEffect)(function() {
    setCurrentChannel(props.currentChannel);
  }, [props.currentChannel]);
  (0, import_react.useEffect)(function() {
    setChannels(props.channels);
  }, [props.channels]);
  (0, import_react.useEffect)(function() {
    setChannelGroups(props.channelGroups);
  }, [props.channelGroups]);
  (0, import_react.useEffect)(function() {
    setErrorFunction({ function: function(error) {
      return props.onError(error);
    } });
  }, [props.onError]);
  (0, import_react.useEffect)(function() {
    setRetryFunction({ function: function(fn) {
      return retryOnError(fn);
    } });
  }, [retryOnError]);
  (0, import_react.useEffect)(function() {
    if (!pubnub)
      return;
    setupListeners();
    window.addEventListener("beforeunload", function() {
      pubnub.stop();
    });
    return function() {
      pubnub.stop();
    };
  }, [pubnub]);
  (0, import_react.useEffect)(function() {
    if (!currentChannel)
      return;
    if (!channels.includes(currentChannel) && !props.channels.length && !props.channelGroups.length) {
      setChannels(__spreadArray(__spreadArray([], channels), [currentChannel]));
    }
  }, [currentChannel]);
  (0, import_react.useEffect)(function() {
    if (!channels.length && !channelGroups.length)
      return;
    setupSubscriptions();
  }, [channels, channelGroups]);
  var setupListeners = function() {
    try {
      pubnub.addListener({
        message: function(m) {
          return handleMessage(m);
        },
        messageAction: function(m) {
          return handleAction(m);
        },
        presence: function(e) {
          return handlePresenceEvent(e);
        },
        objects: function(e) {
          return handleObjectsEvent(e);
        },
        signal: function(e) {
          return handleSignalEvent(e);
        },
        file: function(e) {
          return handleFileEvent(e);
        },
        status: function(e) {
          return handleStatusEvent(e);
        }
      });
    } catch (e) {
      props.onError(e);
    }
  };
  var setupSubscriptions = function() {
    try {
      var currentSubscriptions_1 = pubnub.getSubscribedChannels();
      var newChannels = channels.filter(function(c) {
        return !currentSubscriptions_1.includes(c);
      });
      var currentGroups_1 = pubnub.getSubscribedChannelGroups();
      var newGroups = channelGroups.filter(function(c) {
        return !currentGroups_1.includes(c);
      });
      if (newChannels.length || newGroups.length) {
        pubnub.subscribe({
          channels: newChannels,
          channelGroups: newGroups,
          withPresence: props.enablePresence
        });
      }
    } catch (e) {
      props.onError(e);
    }
  };
  var handleMessage = function(message) {
    if (props.onMessage)
      props.onMessage(message);
    try {
      setMessages(function(messages) {
        var messagesClone = lodash_clonedeep(messages) || {};
        messagesClone[message.channel] = messagesClone[message.channel] || [];
        messagesClone[message.channel].push(message);
        return messagesClone;
      });
    } catch (e) {
      props.onError(e);
    }
  };
  var handleSignalEvent = function(signal) {
    if (props.onSignal)
      props.onSignal(signal);
    try {
      if (["typing_on", "typing_off"].includes(signal.message.type)) {
        setTypingIndicator(function(indicators) {
          var indicatorsClone = lodash_clonedeep(indicators);
          var value = signal.message.type === "typing_on" ? signal.timetoken : null;
          lodash_set(indicatorsClone, [signal.channel, signal.publisher], value);
          return indicatorsClone;
        });
      }
    } catch (e) {
      props.onError(e);
    }
  };
  var handlePresenceEvent = function(event2) {
    if (props.onPresence)
      props.onPresence(event2);
  };
  var handleObjectsEvent = function(event2) {
    if (event2.message.type === "membership" && props.onMembership)
      props.onMembership(event2);
    if (event2.message.type === "channel" && props.onChannel)
      props.onChannel(event2);
    if (event2.message.type === "uuid" && props.onUser)
      props.onUser(event2);
  };
  var handleAction = function(action) {
    if (props.onMessageAction)
      props.onMessageAction(action);
    try {
      setMessages(function(messages) {
        var _a2, _b2;
        if (!messages || !messages[action.channel])
          return;
        var channel = action.channel, event2 = action.event;
        var _c2 = action.data, type = _c2.type, value = _c2.value, actionTimetoken = _c2.actionTimetoken, messageTimetoken = _c2.messageTimetoken, uuid = _c2.uuid;
        var messagesClone = lodash_clonedeep(messages);
        var message = messagesClone[channel].find(function(m) {
          return m.timetoken === messageTimetoken;
        });
        var actions = ((_b2 = (_a2 = message === null || message === void 0 ? void 0 : message.actions) === null || _a2 === void 0 ? void 0 : _a2[type]) === null || _b2 === void 0 ? void 0 : _b2[value]) || [];
        if (message && event2 === "added") {
          var newActions = __spreadArray(__spreadArray([], actions), [{ uuid, actionTimetoken }]);
          lodash_set(message, ["actions", type, value], newActions);
        }
        if (message && event2 === "removed") {
          var newActions = actions.filter(function(a) {
            return a.actionTimetoken !== actionTimetoken;
          });
          newActions.length ? lodash_set(message, ["actions", type, value], newActions) : delete message.actions[type][value];
        }
        return messagesClone;
      });
    } catch (e) {
      props.onError(e);
    }
  };
  var handleFileEvent = function(event2) {
    if (props.onFile)
      props.onFile(event2);
    try {
      setMessages(function(messages) {
        var file = event2.file, message = event2.message, payload = __rest(event2, ["file", "message"]);
        var newMessage = __assign(__assign({}, payload), { message: { file, message }, messageType: 4 });
        var messagesClone = lodash_clonedeep(messages) || {};
        messagesClone[newMessage.channel] = messagesClone[newMessage.channel] || [];
        messagesClone[newMessage.channel].push(newMessage);
        return messagesClone;
      });
    } catch (e) {
      props.onError(e);
    }
  };
  var handleStatusEvent = function(event2) {
    if (props.onStatus)
      props.onStatus(event2);
  };
  return import_react.default.createElement(import_react.default.Fragment, null, props.children);
};
var getNameInitials = function(name) {
  if (!name || !name.length)
    return "";
  var nameSplit = name.split(" ");
  var initials = nameSplit.length == 1 ? nameSplit[0].substring(0, 2) : nameSplit[0][0] + nameSplit[1][0];
  return initials.toUpperCase();
};
var getPredefinedColor = function(uuid) {
  if (!uuid || !uuid.length)
    return;
  var colors = ["#80deea", "#9fa7df", "#aed581", "#ce93d8", "#ef9a9a", "#ffab91", "#ffe082"];
  var sum = uuid.split("").map(function(c) {
    return c.charCodeAt(0);
  }).reduce(function(a, b) {
    return a + b;
  });
  return colors[sum % colors.length];
};
var useOuterClick = function(callback) {
  var callbackRef = (0, import_react.useRef)();
  var innerRef = (0, import_react.useRef)();
  (0, import_react.useEffect)(function() {
    callbackRef.current = callback;
  });
  (0, import_react.useEffect)(function() {
    var handleClick = function(e) {
      if (innerRef.current && callbackRef.current && !innerRef.current.contains(e.target))
        callbackRef.current(e);
    };
    document.addEventListener("click", handleClick);
    return function() {
      document.removeEventListener("click", handleClick);
    };
  }, []);
  return innerRef;
};
var css_248z$4 = "/* ************************\n** Variables\n** ********************* */\n:root {\n  --msg-input__background: var(--chat--light__background--1);\n  --msg-input__padding: 10px 18px;\n  --msg-input__emoji-picker__bottom: 14px;\n  --msg-input__emoji-picker__left: 10px;\n  --msg-input__icon__color: var(--chat--light__color--2);\n  --msg-input__icon__margin: 0 18px 0 0;\n  --msg-input__icon__fontSize: 13px;\n  --msg-input__send__background: transparent;\n  --msg-input__send__border: none;\n  --msg-input__send__borderRadius: 5px;\n  --msg-input__send__color: var(--chat--light__color--2);\n  --msg-input__send--active__color: var(--chat--light__hover--1);\n  --msg-input__send__fontFamily: inherit;\n  --msg-input__send__fontSize: 13px;\n  --msg-input__send__fontWeight: bold;\n  --msg-input__send__margin: 0 0 0 18px;\n  --msg-input__send__minWidth: 0;\n  --msg-input__send__padding: 0;\n  --msg-input--disabled__placeholder__color: rgba(var(--chat--light__color--2-rgb), 0.5);\n  --msg-input__placeholder__color: var(--chat--light__color--2);\n  --msg-input__textarea--focus__border: 1px solid transparent;\n  --msg-input__textarea--focus__outline: none;\n  --msg-input__textarea__background: var(--chat--light__hover--2);\n  --msg-input--disabled__textarea__background: var(--chat--light__background--3);\n  --msg-input__textarea__border: 1px solid transparent;\n  --msg-input--disabled__textarea__border: 1px solid transparent;\n  --msg-input__textarea__borderRadius: 20px;\n  --msg-input__textarea__boxShadow: none;\n  --msg-input__textarea__color: var(--chat--light__color--1);\n  --msg-input__textarea__fontFamily: inherit;\n  --msg-input__textarea__fontSize: 13px;\n  --msg-input__textarea__height: 32px;\n  --msg-input__textarea__lineHeight: 18px;\n  --msg-input__textarea__outline: none;\n  --msg-input__textarea__padding: 6px 14px 8px;\n  --msg-input__textarea__resize: none;\n  --msg-input__textarea__width: 100%;\n  --msg-input__textarea__overflow: hidden;\n}\n\n/* ************************\n** Styles\n** ********************* */\n.pn-msg-input {\n  background: var(--msg-input__background);\n  padding: var(--msg-input__padding);\n}\n.pn-msg-input__wrapper {\n  align-items: center;\n  display: flex;\n  position: relative;\n}\n.pn-msg-input__textarea {\n  background: var(--msg-input__textarea__background);\n  border-radius: var(--msg-input__textarea__borderRadius);\n  border: var(--msg-input__textarea__border);\n  box-shadow: var(--msg-input__textarea__boxShadow);\n  box-sizing: border-box;\n  color: var(--msg-input__textarea__color);\n  font-family: var(--msg-input__textarea__fontFamily);\n  font-size: var(--msg-input__textarea__fontSize);\n  height: var(--msg-input__textarea__height);\n  line-height: var(--msg-input__textarea__lineHeight);\n  outline: var(--msg-input__textarea__outline);\n  padding: var(--msg-input__textarea__padding);\n  resize: var(--msg-input__textarea__resize);\n  width: var(--msg-input__textarea__width);\n  overflow: var(--msg-input__textarea__overflow);\n}\n.pn-msg-input__textarea:focus-within {\n  outline: var(--msg-input__textarea--focus__outline);\n  border: var(--msg-input__textarea--focus__border);\n}\n.pn-msg-input__textarea::placeholder {\n  color: var(--msg-input__placeholder__color);\n}\n.pn-msg-input__send {\n  background: var(--msg-input__send__background);\n  border-radius: var(--msg-input__send__borderRadius);\n  border: var(--msg-input__send__border);\n  color: var(--msg-input__send__color);\n  cursor: pointer;\n  flex-shrink: 0;\n  font-family: var(--msg-input__send__fontFamily);\n  font-size: var(--msg-input__send__fontSize);\n  font-weight: var(--msg-input__send__fontWeight);\n  margin: var(--msg-input__send__margin);\n  min-width: var(--msg-input__send__minWidth);\n  outline: none;\n  padding: var(--msg-input__send__padding);\n  white-space: nowrap;\n}\n.pn-msg-input__send--active {\n  color: var(--msg-input__send--active__color);\n}\n.pn-msg-input__emoji-picker {\n  bottom: var(--msg-input__emoji-picker__bottom);\n  left: var(--msg-input__emoji-picker__left);\n  position: absolute;\n}\n.pn-msg-input__icons {\n  align-items: center;\n  display: flex;\n}\n.pn-msg-input__icons > * {\n  cursor: pointer;\n  color: var(--msg-input__icon__color);\n  font-size: var(--msg-input__icon__fontSize);\n  margin: var(--msg-input__icon__margin);\n}\n.pn-msg-input__fileLabel {\n  cursor: pointer;\n}\n.pn-msg-input__fileInput {\n  display: none;\n}\n\n.pn-msg-input--disabled .pn-msg-input__textarea {\n  background: var(--msg-input--disabled__textarea__background);\n  border: var(--msg-input--disabled__textarea__border);\n  cursor: not-allowed;\n}\n.pn-msg-input--disabled .pn-msg-input__textarea::placeholder {\n  color: var(--msg-input--disabled__placeholder__color);\n}\n\n/* ************************\n** Themes\n** ********************* */\n.pn-msg-input--dark,\n.pn-msg-input--event-dark,\n.pn-msg-input--support-dark {\n  --msg-input__background: var(--chat--dark__background--1);\n  --msg-input__icon__color: var(--chat--dark__color--2);\n  --msg-input__send__color: var(--chat--dark__color--2);\n  --msg-input__send--active__color: var(--chat--dark__hover--1);\n  --msg-input--disabled__placeholder__color: rgba(var(--chat--dark__hover--4-rgb), 0.5);\n  --msg-input__placeholder__color: var(--chat--dark__hover--4);\n  --msg-input__textarea__background: var(--chat--dark__background--2);\n  --msg-input--disabled__textarea__background: rgba(var(--chat--dark__background--2-rgb), 0.5);\n  --msg-input__textarea__color: var(--chat--dark__color--1);\n}";
styleInject(css_248z$4);
var _path$6;
function _extends$7() {
  _extends$7 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function SvgEmoji(props) {
  return React.createElement("svg", _extends$7({
    xmlns: "http://www.w3.org/2000/svg",
    overflow: "visible",
    preserveAspectRatio: "none",
    viewBox: "0 0 24 24",
    width: 20,
    height: 20
  }, props), _path$6 || (_path$6 = React.createElement("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z",
    fill: "currentColor",
    vectorEffect: "non-scaling-stroke"
  })));
}
var _path$5;
var _path2$2;
function _extends$6() {
  _extends$6 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function SvgFile(props) {
  return React.createElement("svg", _extends$6({
    xmlns: "http://www.w3.org/2000/svg",
    height: 20,
    viewBox: "0 0 24 24",
    width: 20,
    fill: "currentColor"
  }, props), _path$5 || (_path$5 = React.createElement("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  })), _path2$2 || (_path2$2 = React.createElement("path", {
    d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"
  })));
}
var _path$4;
function _extends$5() {
  _extends$5 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function SvgImage(props) {
  return React.createElement("svg", _extends$5({
    xmlns: "http://www.w3.org/2000/svg",
    overflow: "visible",
    preserveAspectRatio: "none",
    viewBox: "0 0 24 24",
    width: 20,
    height: 20
  }, props), _path$4 || (_path$4 = React.createElement("path", {
    d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z",
    fill: "currentColor",
    vectorEffect: "non-scaling-stroke"
  })));
}
var _path$3;
function _extends$4() {
  _extends$4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function SvgXCircle(props) {
  return React.createElement("svg", _extends$4({
    xmlns: "http://www.w3.org/2000/svg",
    width: 16,
    height: 16
  }, props), _path$3 || (_path$3 = React.createElement("path", {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M3.404 12.596a6.5 6.5 0 119.192-9.192 6.5 6.5 0 01-9.192 9.192zM2.344 2.343a8 8 0 1011.313 11.314A8 8 0 002.343 2.343zM6.03 4.97a.75.75 0 00-1.06 1.06L6.94 8 4.97 9.97a.75.75 0 101.06 1.06L8 9.06l1.97 1.97a.75.75 0 101.06-1.06L9.06 8l1.97-1.97a.75.75 0 10-1.06-1.06L8 6.94 6.03 4.97z"
  })));
}
var _circle;
function _extends$3() {
  _extends$3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function SvgSpinner(props) {
  return React.createElement("svg", _extends$3({
    xmlns: "http://www.w3.org/2000/svg",
    style: {
      margin: "auto",
      background: "0 0"
    },
    width: 20,
    height: 20,
    viewBox: "0 0 100 100",
    preserveAspectRatio: "xMidYMid",
    display: "block"
  }, props), _circle || (_circle = React.createElement("circle", {
    cx: 50,
    cy: 50,
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 15,
    r: 43,
    strokeDasharray: "117.80972450961724 41.269908169872416"
  }, React.createElement("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    repeatCount: "indefinite",
    dur: "0.641025641025641s",
    values: "0 50 50;360 50 50",
    keyTimes: "0;1"
  }))));
}
var _path$2;
function _extends$2() {
  _extends$2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function SvgAirplane(props) {
  return React.createElement("svg", _extends$2({
    xmlns: "http://www.w3.org/2000/svg",
    overflow: "visible",
    preserveAspectRatio: "none",
    viewBox: "0 0 24 24",
    width: 20,
    height: 20
  }, props), _path$2 || (_path$2 = React.createElement("path", {
    fill: "currentColor",
    vectorEffect: "non-scaling-stroke",
    d: "M2 21l21-9L2 3v7l15 2-15 2z"
  })));
}
var MessageInput = function(props) {
  var pubnub = usePubNub();
  var _a = (0, import_react.useState)(props.draftMessage || ""), text = _a[0], setText = _a[1];
  var _b = (0, import_react.useState)(null), file = _b[0], setFile = _b[1];
  var _c = (0, import_react.useState)(false), emojiPickerShown = _c[0], setEmojiPickerShown = _c[1];
  var _d = (0, import_react.useState)(false), typingIndicatorSent = _d[0], setTypingIndicatorSent = _d[1];
  var _e = (0, import_react.useState)(), picker = _e[0], setPicker = _e[1];
  var _f = (0, import_react.useState)(false), loader = _f[0], setLoader = _f[1];
  var users = jotai.useAtom(UsersMetaAtom)[0];
  var theme = jotai.useAtom(ThemeAtom)[0];
  var channel = jotai.useAtom(CurrentChannelAtom)[0];
  var onErrorObj = jotai.useAtom(ErrorFunctionAtom)[0];
  var onError = onErrorObj.function;
  var typingIndicatorTimeout = jotai.useAtom(TypingIndicatorTimeoutAtom)[0];
  var inputRef = (0, import_react.useRef)(null);
  var fileRef = (0, import_react.useRef)(null);
  var pickerRef = useOuterClick(function() {
    if (event.target.closest(".pn-msg-input__emoji-toggle"))
      return;
    setEmojiPickerShown(false);
  });
  var autoSize = function() {
    var input = inputRef.current;
    if (!input)
      return;
    setTimeout(function() {
      input.style.cssText = "height: auto;";
      input.style.cssText = "height: " + input.scrollHeight + "px;";
    }, 0);
  };
  var sendMessage = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var message, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 5, 6, 7]);
            if (!file && !text)
              return [2];
            setLoader(true);
            if (!file)
              return [3, 2];
            return [4, pubnub.sendFile({ channel, file })];
          case 1:
            _a2.sent();
            props.onSend && props.onSend(file);
            return [3, 4];
          case 2:
            if (!text)
              return [3, 4];
            message = __assign({ type: "text", text }, props.senderInfo && { sender: users.find(function(u) {
              return u.id === pubnub.getUUID();
            }) });
            return [4, pubnub.publish({ channel, message })];
          case 3:
            _a2.sent();
            props.onSend && props.onSend(message);
            _a2.label = 4;
          case 4:
            if (props.typingIndicator)
              stopTypingIndicator();
            clearInput();
            return [3, 7];
          case 5:
            e_1 = _a2.sent();
            onError(e_1);
            return [3, 7];
          case 6:
            setLoader(false);
            return [7];
          case 7:
            return [2];
        }
      });
    });
  };
  var startTypingIndicator = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var message;
      return __generator(this, function(_a2) {
        if (typingIndicatorSent)
          return [2];
        try {
          setTypingIndicatorSent(true);
          message = { message: { type: "typing_on" }, channel };
          pubnub.signal(message);
        } catch (e) {
          onError(e);
        }
        return [2];
      });
    });
  };
  var stopTypingIndicator = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var message;
      return __generator(this, function(_a2) {
        if (!typingIndicatorSent)
          return [2];
        try {
          setTypingIndicatorSent(false);
          message = { message: { type: "typing_off" }, channel };
          pubnub.signal(message);
        } catch (e) {
          onError(e);
        }
        return [2];
      });
    });
  };
  var clearInput = function() {
    setFile(null);
    setText("");
    autoSize();
    fileRef.current.value = null;
  };
  var handleEmojiInsertion = function(emoji) {
    try {
      if (!("native" in emoji))
        return;
      setText(text + emoji.native);
      setEmojiPickerShown(false);
    } catch (e) {
      onError(e);
    }
  };
  var handleKeyPress = function(event2) {
    try {
      if (event2.key === "Enter" && !event2.shiftKey) {
        event2.preventDefault();
        sendMessage();
      }
    } catch (e) {
      onError(e);
    }
  };
  var handleInputChange = function(event2) {
    try {
      var textArea = event2.target;
      var newText = textArea.value;
      if (props.typingIndicator && newText.length)
        startTypingIndicator();
      if (props.typingIndicator && !newText.length)
        stopTypingIndicator();
      props.onChange && props.onChange(newText);
      autoSize();
      setText(newText);
    } catch (e) {
      onError(e);
    }
  };
  var handleFileChange = function(event2) {
    try {
      var file_1 = event2.target.files[0];
      setFile(file_1);
      setText(file_1.name);
    } catch (e) {
      onError(e);
    }
  };
  (0, import_react.useEffect)(function() {
    if (import_react.default.isValidElement(props.emojiPicker)) {
      setPicker(import_react.default.cloneElement(props.emojiPicker, { onSelect: handleEmojiInsertion }));
    }
  }, [props.emojiPicker]);
  (0, import_react.useEffect)(function() {
    var timer = null;
    if (typingIndicatorSent) {
      timer = setTimeout(function() {
        setTypingIndicatorSent(false);
      }, (typingIndicatorTimeout - 1) * 1e3);
    }
    return function() {
      return clearTimeout(timer);
    };
  }, [typingIndicatorSent]);
  var renderFileUpload = function() {
    return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement("div", null, import_react.default.createElement("label", { htmlFor: "file-upload", className: "pn-msg-input__fileLabel", title: "Add a file" }, props.fileUpload === "image" ? import_react.default.createElement(SvgImage, null) : import_react.default.createElement(SvgFile, null)), import_react.default.createElement("input", { accept: props.fileUpload === "image" ? "image/*" : "*", className: "pn-msg-input__fileInput", "data-testid": "file-upload", id: "file-upload", onChange: handleFileChange, ref: fileRef, type: "file" })), file && import_react.default.createElement("div", { title: "Remove the file", onClick: clearInput }, import_react.default.createElement(SvgXCircle, null)));
  };
  var renderEmojiPicker = function() {
    return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement("div", { onClick: function() {
      return setEmojiPickerShown(true);
    }, title: "Add an emoji" }, import_react.default.createElement(SvgEmoji, null)), emojiPickerShown && import_react.default.createElement("div", { className: "pn-msg-input__emoji-picker", ref: pickerRef }, picker));
  };
  return import_react.default.createElement("div", { className: "pn-msg-input pn-msg-input--" + theme + " " + (props.disabled ? "pn-msg-input--disabled" : "") }, import_react.default.createElement("div", { className: "pn-msg-input__wrapper" }, import_react.default.createElement("div", { className: "pn-msg-input__icons" }, import_react.default.createElement("div", { className: "pn-msg-input__emoji-toggle" }, !props.disabled && props.emojiPicker && renderEmojiPicker()), !props.disabled && props.fileUpload && renderFileUpload(), props.extraActionsRenderer && props.extraActionsRenderer()), import_react.default.createElement("textarea", { className: "pn-msg-input__textarea", "data-testid": "message-input", disabled: props.disabled || !!file, onChange: function(e) {
    return handleInputChange(e);
  }, onKeyPress: function(e) {
    return handleKeyPress(e);
  }, placeholder: props.placeholder, ref: inputRef, rows: 1, value: text }), !props.hideSendButton && !props.disabled && import_react.default.createElement("button", { className: "pn-msg-input__send " + (text.length && "pn-msg-input__send--active"), disabled: loader || props.disabled, onClick: function() {
    return sendMessage();
  }, title: "Send" }, loader ? import_react.default.createElement(SvgSpinner, null) : props.sendButton)));
};
MessageInput.defaultProps = {
  disabled: false,
  fileUpload: void 0,
  hideSendButton: false,
  placeholder: "Send message",
  sendButton: import_react.default.createElement(SvgAirplane, null),
  senderInfo: false,
  typingIndicator: false
};
var utils = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var RESET = Symbol();
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it)
      return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var WRITE_ATOM = "w";
  var RESTORE_ATOMS = "h";
  function useUpdateAtom(anAtom, scope) {
    var ScopeContext = jotai.SECRET_INTERNAL_getScopeContext(scope);
    var store = import_react.default.useContext(ScopeContext)[0];
    var setAtom = import_react.default.useCallback(function(update) {
      return store[WRITE_ATOM](anAtom, update);
    }, [store, anAtom]);
    return setAtom;
  }
  function useAtomValue(anAtom, scope) {
    return jotai.useAtom(anAtom, scope)[0];
  }
  function atomWithReset(initialValue) {
    var anAtom = jotai.atom(initialValue, function(get, set2, update) {
      if (update === RESET) {
        set2(anAtom, initialValue);
      } else {
        set2(anAtom, typeof update === "function" ? update(get(anAtom)) : update);
      }
    });
    return anAtom;
  }
  function useResetAtom(anAtom, scope) {
    var ScopeContext = jotai.SECRET_INTERNAL_getScopeContext(scope);
    var store = import_react.default.useContext(ScopeContext)[0];
    var setAtom = import_react.default.useCallback(function() {
      return store[WRITE_ATOM](anAtom, RESET);
    }, [store, anAtom]);
    return setAtom;
  }
  function useReducerAtom(anAtom, reducer, scope) {
    var _useAtom = jotai.useAtom(anAtom, scope), state = _useAtom[0], setState = _useAtom[1];
    var dispatch = import_react.default.useCallback(function(action) {
      setState(function(prev) {
        return reducer(prev, action);
      });
    }, [setState, reducer]);
    return [state, dispatch];
  }
  function atomWithReducer(initialValue, reducer) {
    var anAtom = jotai.atom(initialValue, function(get, set2, action) {
      return set2(anAtom, reducer(get(anAtom), action));
    });
    return anAtom;
  }
  function atomFamily(initializeAtom, areEqual) {
    var shouldRemove = null;
    var atoms = new Map();
    var createAtom = function createAtom2(param) {
      var item;
      if (areEqual === void 0) {
        item = atoms.get(param);
      } else {
        for (var _iterator = _createForOfIteratorHelperLoose(atoms), _step; !(_step = _iterator()).done; ) {
          var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
          if (areEqual(key, param)) {
            item = value;
            break;
          }
        }
      }
      if (item !== void 0) {
        if (shouldRemove != null && shouldRemove(item[1], param)) {
          atoms.delete(param);
        } else {
          return item[0];
        }
      }
      var newAtom = initializeAtom(param);
      atoms.set(param, [newAtom, Date.now()]);
      return newAtom;
    };
    createAtom.remove = function(param) {
      if (areEqual === void 0) {
        atoms.delete(param);
      } else {
        for (var _iterator2 = _createForOfIteratorHelperLoose(atoms), _step2; !(_step2 = _iterator2()).done; ) {
          var _step2$value = _step2.value, key = _step2$value[0];
          if (areEqual(key, param)) {
            atoms.delete(key);
            break;
          }
        }
      }
    };
    createAtom.setShouldRemove = function(fn) {
      shouldRemove = fn;
      if (!shouldRemove)
        return;
      for (var _iterator3 = _createForOfIteratorHelperLoose(atoms), _step3; !(_step3 = _iterator3()).done; ) {
        var _step3$value = _step3.value, key = _step3$value[0], value = _step3$value[1];
        if (shouldRemove(value[1], key)) {
          atoms.delete(key);
        }
      }
    };
    return createAtom;
  }
  var getWeakCacheItem = function getWeakCacheItem2(cache, deps) {
    while (true) {
      var _deps = deps, dep = _deps[0], rest = _deps.slice(1);
      var entry = cache.get(dep);
      if (!entry) {
        return;
      }
      if (!rest.length) {
        return entry[1];
      }
      cache = entry[0];
      deps = rest;
    }
  };
  var setWeakCacheItem = function setWeakCacheItem2(cache, deps, item) {
    while (true) {
      var _deps2 = deps, dep = _deps2[0], rest = _deps2.slice(1);
      var entry = cache.get(dep);
      if (!entry) {
        entry = [new WeakMap()];
        cache.set(dep, entry);
      }
      if (!rest.length) {
        entry[1] = item;
        return;
      }
      cache = entry[0];
      deps = rest;
    }
  };
  var selectAtomCache = new WeakMap();
  function selectAtom(anAtom, selector, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = Object.is;
    }
    var deps = [anAtom, selector, equalityFn];
    var cachedAtom = getWeakCacheItem(selectAtomCache, deps);
    if (cachedAtom) {
      return cachedAtom;
    }
    var refAtom = jotai.atom(function() {
      return {};
    });
    var derivedAtom = jotai.atom(function(get) {
      var slice = selector(get(anAtom));
      var ref = get(refAtom);
      if ("prev" in ref && equalityFn(ref.prev, slice)) {
        return ref.prev;
      }
      ref.prev = slice;
      return slice;
    });
    setWeakCacheItem(selectAtomCache, deps, derivedAtom);
    return derivedAtom;
  }
  function useAtomCallback(callback, scope) {
    var anAtom = import_react.default.useMemo(function() {
      return jotai.atom(null, function(get, set2, _ref) {
        var arg = _ref[0], resolve = _ref[1], reject = _ref[2];
        try {
          resolve(callback(get, set2, arg));
        } catch (e) {
          reject(e);
        }
      });
    }, [callback]);
    var invoke = useUpdateAtom(anAtom, scope);
    return import_react.default.useCallback(function(arg) {
      return new Promise(function(resolve, reject) {
        invoke([arg, resolve, reject]);
      });
    }, [invoke]);
  }
  var freezeAtomCache = new WeakMap();
  var deepFreeze = function deepFreeze2(obj) {
    if (typeof obj !== "object" || obj === null)
      return;
    Object.freeze(obj);
    var propNames = Object.getOwnPropertyNames(obj);
    for (var _iterator = _createForOfIteratorHelperLoose(propNames), _step; !(_step = _iterator()).done; ) {
      var name = _step.value;
      var value = obj[name];
      deepFreeze2(value);
    }
    return obj;
  };
  function freezeAtom(anAtom) {
    var deps = [anAtom];
    var cachedAtom = getWeakCacheItem(freezeAtomCache, deps);
    if (cachedAtom) {
      return cachedAtom;
    }
    var frozenAtom = jotai.atom(function(get) {
      return deepFreeze(get(anAtom));
    }, function(_get, set2, arg) {
      return set2(anAtom, arg);
    });
    setWeakCacheItem(freezeAtomCache, deps, frozenAtom);
    return frozenAtom;
  }
  function freezeAtomCreator(createAtom) {
    return function() {
      var anAtom = createAtom.apply(void 0, arguments);
      var origRead = anAtom.read;
      anAtom.read = function(get) {
        return deepFreeze(origRead(get));
      };
      return anAtom;
    };
  }
  var splitAtomCache = new WeakMap();
  var isWritable = function isWritable2(atom) {
    return !!atom.write;
  };
  var isFunction2 = function isFunction3(x) {
    return typeof x === "function";
  };
  function splitAtom(arrAtom, keyExtractor) {
    var deps = keyExtractor ? [arrAtom, keyExtractor] : [arrAtom];
    var cachedAtom = getWeakCacheItem(splitAtomCache, deps);
    if (cachedAtom) {
      return cachedAtom;
    }
    var refAtom = jotai.atom(function() {
      return {};
    });
    var read = function read2(get) {
      var ref = get(refAtom);
      var nextAtomList = [];
      var nextKeyList = [];
      get(arrAtom).forEach(function(item, index) {
        var _ref$atomList, _ref$keyList$indexOf, _ref$keyList;
        var key = keyExtractor ? keyExtractor(item) : index;
        nextKeyList[index] = key;
        var cachedAtom2 = (_ref$atomList = ref.atomList) == null ? void 0 : _ref$atomList[(_ref$keyList$indexOf = (_ref$keyList = ref.keyList) == null ? void 0 : _ref$keyList.indexOf(key)) != null ? _ref$keyList$indexOf : -1];
        if (cachedAtom2) {
          nextAtomList[index] = cachedAtom2;
          return;
        }
        var read3 = function read4(get2) {
          var _ref$keyList$indexOf2, _ref$keyList2;
          var index2 = (_ref$keyList$indexOf2 = (_ref$keyList2 = ref.keyList) == null ? void 0 : _ref$keyList2.indexOf(key)) != null ? _ref$keyList$indexOf2 : -1;
          if (index2 === -1 && typeof process === "object" && true) {
            console.warn("splitAtom: array index out of bounds, returning undefined", jotai.atom);
          }
          return get2(arrAtom)[index2];
        };
        var write2 = function write3(get2, set2, update) {
          var _ref$keyList$indexOf3, _ref$keyList3;
          var index2 = (_ref$keyList$indexOf3 = (_ref$keyList3 = ref.keyList) == null ? void 0 : _ref$keyList3.indexOf(key)) != null ? _ref$keyList$indexOf3 : -1;
          if (index2 === -1) {
            throw new Error("splitAtom: array index not found");
          }
          var prev = get2(arrAtom);
          var nextItem = isFunction2(update) ? update(prev[index2]) : update;
          set2(arrAtom, [].concat(prev.slice(0, index2), [nextItem], prev.slice(index2 + 1)));
        };
        var itemAtom = isWritable(arrAtom) ? jotai.atom(read3, write2) : jotai.atom(read3);
        nextAtomList[index] = itemAtom;
      });
      ref.keyList = nextKeyList;
      if (ref.atomList && ref.atomList.length === nextAtomList.length && ref.atomList.every(function(x, i) {
        return x === nextAtomList[i];
      })) {
        return ref.atomList;
      }
      return ref.atomList = nextAtomList;
    };
    var write = function write2(get, set2, atomToRemove) {
      var index = get(splittedAtom).indexOf(atomToRemove);
      if (index >= 0) {
        var prev = get(arrAtom);
        set2(arrAtom, [].concat(prev.slice(0, index), prev.slice(index + 1)));
      }
    };
    var splittedAtom = isWritable(arrAtom) ? jotai.atom(read, write) : jotai.atom(read);
    setWeakCacheItem(splitAtomCache, deps, splittedAtom);
    return splittedAtom;
  }
  function atomWithDefault(getDefault) {
    var EMPTY = Symbol();
    var overwrittenAtom = jotai.atom(EMPTY);
    var anAtom = jotai.atom(function(get) {
      var overwritten = get(overwrittenAtom);
      if (overwritten !== EMPTY) {
        return overwritten;
      }
      return getDefault(get);
    }, function(get, set2, update) {
      if (update === RESET) {
        set2(overwrittenAtom, EMPTY);
      } else {
        set2(overwrittenAtom, typeof update === "function" ? update(get(anAtom)) : update);
      }
    });
    return anAtom;
  }
  var waitForAllCache = new WeakMap();
  function waitForAll(atoms) {
    var cachedAtom = Array.isArray(atoms) && getWeakCacheItem(waitForAllCache, atoms);
    if (cachedAtom) {
      return cachedAtom;
    }
    var unwrappedAtoms = unwrapAtoms(atoms);
    var derivedAtom = jotai.atom(function(get) {
      var promises = [];
      var values = unwrappedAtoms.map(function(anAtom, index) {
        try {
          return get(anAtom);
        } catch (e) {
          if (e instanceof Promise) {
            promises[index] = e;
          } else {
            throw e;
          }
        }
      });
      if (promises.length) {
        throw Promise.all(promises);
      }
      return wrapResults(atoms, values);
    });
    if (Array.isArray(atoms)) {
      setWeakCacheItem(waitForAllCache, atoms, derivedAtom);
    }
    return derivedAtom;
  }
  var unwrapAtoms = function unwrapAtoms2(atoms) {
    return Array.isArray(atoms) ? atoms : Object.getOwnPropertyNames(atoms).map(function(key) {
      return atoms[key];
    });
  };
  var wrapResults = function wrapResults2(atoms, results) {
    return Array.isArray(atoms) ? results : Object.getOwnPropertyNames(atoms).reduce(function(out, key, idx) {
      var _extends22;
      return _extends2({}, out, (_extends22 = {}, _extends22[key] = results[idx], _extends22));
    }, {});
  };
  var createJSONStorage = function createJSONStorage2(getStringStorage) {
    return {
      getItem: function getItem(key) {
        var value = getStringStorage().getItem(key);
        if (value instanceof Promise) {
          return value.then(function(v) {
            return JSON.parse(v || "");
          });
        }
        return JSON.parse(value || "");
      },
      setItem: function setItem(key, newValue) {
        getStringStorage().setItem(key, JSON.stringify(newValue));
      }
    };
  };
  var defaultStorage = createJSONStorage(function() {
    return localStorage;
  });
  function atomWithStorage(key, initialValue, storage) {
    if (storage === void 0) {
      storage = defaultStorage;
    }
    var getInitialValue = function getInitialValue2() {
      try {
        var _value = storage.getItem(key);
        if (_value instanceof Promise) {
          return _value.catch(function() {
            return initialValue;
          });
        }
        return _value;
      } catch (_unused) {
        return initialValue;
      }
    };
    var baseAtom = jotai.atom(storage.delayInit ? initialValue : getInitialValue());
    baseAtom.onMount = function(setAtom) {
      var unsub;
      if (storage.subscribe) {
        unsub = storage.subscribe(key, setAtom);
      }
      if (storage.delayInit) {
        var _value2 = getInitialValue();
        if (_value2 instanceof Promise) {
          _value2.then(setAtom);
        } else {
          setAtom(_value2);
        }
      }
      return unsub;
    };
    var anAtom = jotai.atom(function(get) {
      return get(baseAtom);
    }, function(get, set2, update) {
      var newValue = typeof update === "function" ? update(get(baseAtom)) : update;
      set2(baseAtom, newValue);
      storage.setItem(key, newValue);
    });
    return anAtom;
  }
  function atomWithHash(key, initialValue, serialize, deserialize) {
    if (serialize === void 0) {
      serialize = JSON.stringify;
    }
    if (deserialize === void 0) {
      deserialize = JSON.parse;
    }
    var hashStorage = {
      getItem: function getItem(key2) {
        var searchParams = new URLSearchParams(location.hash.slice(1));
        var storedValue = searchParams.get(key2);
        if (storedValue === null) {
          throw new Error("no value stored");
        }
        return deserialize(storedValue);
      },
      setItem: function setItem(key2, newValue) {
        var searchParams = new URLSearchParams(location.hash.slice(1));
        searchParams.set(key2, serialize(newValue));
        location.hash = searchParams.toString();
      },
      delayInit: true,
      subscribe: function subscribe(key2, setValue) {
        var callback = function callback2() {
          var searchParams = new URLSearchParams(location.hash.slice(1));
          var str = searchParams.get(key2);
          if (str !== null) {
            setValue(deserialize(str));
          }
        };
        window.addEventListener("hashchange", callback);
        return function() {
          window.removeEventListener("hashchange", callback);
        };
      }
    };
    return atomWithStorage(key, initialValue, hashStorage);
  }
  function atomWithObservable(createObservable) {
    var observableResultAtom = jotai.atom(function(get) {
      var settlePromise = null;
      var observable = createObservable(get);
      var returnsItself = observable[Symbol.observable];
      if (returnsItself) {
        observable = returnsItself();
      }
      var dataAtom = jotai.atom(new Promise(function(resolve, reject) {
        settlePromise = function settlePromise2(data, err) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        };
      }));
      var setData = function setData2() {
        throw new Error("setting data without mount");
      };
      var dataListener = function dataListener2(data) {
        if (settlePromise) {
          settlePromise(data);
          settlePromise = null;
          if (subscription && !setData) {
            subscription.unsubscribe();
            subscription = null;
          }
        } else {
          setData(data);
        }
      };
      var errorListener = function errorListener2(error) {
        if (settlePromise) {
          settlePromise(null, error);
          settlePromise = null;
          if (subscription && !setData) {
            subscription.unsubscribe();
            subscription = null;
          }
        } else {
          setData(Promise.reject(error));
        }
      };
      var subscription = null;
      subscription = observable.subscribe(dataListener, errorListener);
      if (!settlePromise) {
        subscription.unsubscribe();
        subscription = null;
      }
      dataAtom.onMount = function(update) {
        setData = update;
        if (!subscription) {
          subscription = observable.subscribe(dataListener, errorListener);
        }
        return function() {
          var _subscription;
          return (_subscription = subscription) == null ? void 0 : _subscription.unsubscribe();
        };
      };
      return {
        dataAtom,
        observable
      };
    });
    var observableAtom = jotai.atom(function(get) {
      var _get = get(observableResultAtom), dataAtom = _get.dataAtom;
      return get(dataAtom);
    }, function(get, _set, data) {
      var _get2 = get(observableResultAtom), observable = _get2.observable;
      if ("next" in observable) {
        observable.next(data);
      } else {
        throw new Error("observable is not subject");
      }
    });
    return observableAtom;
  }
  var hydratedMap = new WeakMap();
  function useHydrateAtoms(values, scope) {
    var ScopeContext = jotai.SECRET_INTERNAL_getScopeContext(scope);
    var scopeContainer = import_react.default.useContext(ScopeContext);
    var store = scopeContainer[0];
    var hydratedSet = getHydratedSet(scopeContainer);
    var tuplesToRestore = [];
    for (var _iterator = _createForOfIteratorHelperLoose(values), _step; !(_step = _iterator()).done; ) {
      var tuple = _step.value;
      var atom = tuple[0];
      if (!hydratedSet.has(atom)) {
        hydratedSet.add(atom);
        tuplesToRestore.push(tuple);
      }
    }
    if (tuplesToRestore.length) {
      store[RESTORE_ATOMS](tuplesToRestore);
    }
  }
  function getHydratedSet(scopeContainer) {
    var hydratedSet = hydratedMap.get(scopeContainer);
    if (!hydratedSet) {
      hydratedSet = new WeakSet();
      hydratedMap.set(scopeContainer, hydratedSet);
    }
    return hydratedSet;
  }
  exports.RESET = RESET;
  exports.atomFamily = atomFamily;
  exports.atomWithDefault = atomWithDefault;
  exports.atomWithHash = atomWithHash;
  exports.atomWithObservable = atomWithObservable;
  exports.atomWithReducer = atomWithReducer;
  exports.atomWithReset = atomWithReset;
  exports.atomWithStorage = atomWithStorage;
  exports.createJSONStorage = createJSONStorage;
  exports.freezeAtom = freezeAtom;
  exports.freezeAtomCreator = freezeAtomCreator;
  exports.selectAtom = selectAtom;
  exports.splitAtom = splitAtom;
  exports.useAtomCallback = useAtomCallback;
  exports.useAtomValue = useAtomValue;
  exports.useHydrateAtoms = useHydrateAtoms;
  exports.useReducerAtom = useReducerAtom;
  exports.useResetAtom = useResetAtom;
  exports.useUpdateAtom = useUpdateAtom;
  exports.waitForAll = waitForAll;
});
var _path$1;
var _path2$1;
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function SvgDownload(props) {
  return React.createElement("svg", _extends$1({
    xmlns: "http://www.w3.org/2000/svg",
    height: 20,
    viewBox: "0 0 24 24",
    width: 20,
    fill: "currentColor"
  }, props), _path$1 || (_path$1 = React.createElement("path", {
    fill: "none",
    d: "M0 0h24v24H0z"
  })), _path2$1 || (_path2$1 = React.createElement("path", {
    d: "M18 15v3H6v-3H4v3c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3h-2zm-1-4l-1.41-1.41L13 12.17V4h-2v8.17L8.41 9.59 7 11l5 5 5-5z"
  })));
}
var _path;
var _path2;
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function SvgArrowDown(props) {
  return React.createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    height: 16,
    viewBox: "0 0 24 24",
    width: 16,
    fill: "currentColor"
  }, props), _path || (_path = React.createElement("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  })), _path2 || (_path2 = React.createElement("path", {
    d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
  })));
}
var css_248z$3 = '/* ************************\n** Variables\n** ********************* */\n:root {\n  --msg-list__background: var(--chat--light__background--1);\n  --msg-list__padding: 0;\n  --msg-list__unread__background: var(--chat--light__color--2);\n  --msg-list__unread__borderRadius: 20px;\n  --msg-list__unread__color: var(--chat--light__background--2);\n  --msg-list__unread__fontSize: 13px;\n  --msg-list__unread__fontWeight: 400;\n  --msg-list__unread__padding: 8px 16px;\n  --msg-list__unread__offset: 50px;\n  --msg-list__spinner__color: var(--chat--light__color--2);\n  --msg-list__spinner__margin: 10px auto;\n  --msg--hover__background: var(--chat--light__hover--3);\n  --msg__alignItems: flex-start;\n  --msg__flexDirection: row;\n  --msg__height: auto;\n  --msg__padding: 10px 16px;\n  --msg__actions--hover__background: transparent;\n  --msg__actions--hover__color: var(--chat--light__hover--1);\n  --msg__actions--hover__border: 1px solid var(--chat--light__border--1);\n  --msg__actions__background: transparent;\n  --msg__actions__border: 1px solid var(--chat--light__border--1);\n  --msg__actions__borderRadius: 15px;\n  --msg__actions__color: var(--chat--light__color--2);\n  --msg__actions__fontSize: 22px;\n  --msg__actions__margin: 0 0 0 4px;\n  --msg__actions__padding: 0 7px;\n  --msg__actions__right: 10px;\n  --msg__actions__top: 10px;\n  --msg__author__color: var(--chat--light__color--1);\n  --msg__author__fontSize: 15px;\n  --msg__author__fontWeight: 500;\n  --msg__author__padding: 0;\n  --msg__avatar__display: flex;\n  --msg__avatar__fontSize: 10px;\n  --msg__avatar__margin: 2px 18px 0 0;\n  --msg__avatar__size: 36px;\n  --msg__avatar__borderRadius: 36px;\n  --msg__bubble__background: transparent;\n  --msg__bubble__boxShadow: none;\n  --msg__bubble__borderRadius: 0;\n  --msg__bubble__color: var(--chat--light__color--1);\n  --msg__bubble__fontSize: 13px;\n  --msg__bubble__fontWeight: 400;\n  --msg__bubble__margin: 0;\n  --msg__bubble__padding: 0;\n  --msg__content__alignItems: flex-start;\n  --msg__content__flexDirection: column;\n  --msg__content__margin: 0;\n  --msg__image__borderRadius: 10px;\n  --msg__image__margin: 15px 0 0;\n  --msg__link__margin: 10px 0 0;\n  --msg__link__padding: 20px;\n  --msg__link-description__color: var(--chat--light__color--2);\n  --msg__link-thumb__maxWidth: 210px;\n  --msg__link-title__color: var(--chat--light__color--1);\n  --msg__main__alignItems: flex-start;\n  --msg__main__flexDirection: column;\n  --msg__main__margin: 0;\n  --msg__main__maxWidth: 60%;\n  --msg__time__display: block;\n  --msg__time__color: var(--chat--light__color--1);\n  --msg__time__fontSize: 11px;\n  --msg__time__fontWeight: 300;\n  --msg__time__padding: 0 10px;\n  --msg__title__alignItems: baseline;\n  --msg__title__display: flex;\n  --msg__title__margin: 0 0 10px;\n  --msg__reaction--hover__background: var(--chat--light__hover--4);\n  --msg__reaction--hover__border: 1px solid var(--chat--light__border--2);\n  --msg__reaction--active__background: rgba(var(--chat--light__background--5-rgb), 0.2);\n  --msg__reaction--active__border: 1px solid transparent;\n  --msg__reaction--active--hover__background: rgba(var(--chat--light__background--5-rgb), 0.24);\n  --msg__reaction--active--hover__border: 1px solid rgba(var(--chat--light__background--5-rgb), 0.4);\n  --msg__reaction__background: transparent;\n  --msg__reaction__border: 1px solid var(--chat--light__border--1);\n  --msg__reaction__borderRadius: 15px;\n  --msg__reaction__margin: 10px 5px 0 0;\n  --msg__reaction__padding: 0 7px 0 3px;\n  --msg__reaction__wordSpacing: 2px;\n}\n\n/* ************************\n** Styles\n** ********************* */\n.pn-msg-list {\n  background: var(--msg-list__background);\n  height: 100%;\n  overflow: hidden;\n  padding: var(--msg-list__padding);\n  position: relative;\n  width: 100%;\n}\n.pn-msg-list-scroller {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  overflow: auto;\n  overscroll-behavior-y: contain;\n  position: relative;\n  scroll-snap-type: y proximity;\n  transform: translateZ(0);\n  width: 100%;\n}\n.pn-msg-list__spinner {\n  color: var(--msg-list__spinner__color);\n  margin: var(--msg-list__spinner__margin);\n}\n.pn-msg-list__unread {\n  background: var(--msg-list__unread__background);\n  border-radius: var(--msg-list__unread__borderRadius);\n  color: var(--msg-list__unread__color);\n  cursor: pointer;\n  font-size: var(--msg-list__unread__fontSize);\n  font-weight: var(--msg-list__unread__fontWeight);\n  left: 50%;\n  padding: var(--msg-list__unread__padding);\n  position: fixed;\n  top: var(--msg-list__unread__offset);\n  transform: translateX(50%);\n  z-index: 5;\n}\n.pn-msg-list__unread svg {\n  vertical-align: bottom;\n}\n.pn-msg-list__bottom-ref {\n  flex-shrink: 0;\n  height: 1px;\n  scroll-snap-align: end;\n  width: 100%;\n}\n.pn-msg-list__spacer {\n  flex: 1 1 auto;\n}\n.pn-msg-list__emoji-picker {\n  position: absolute;\n  right: 50px;\n  z-index: 10;\n}\n.pn-msg-list__emoji-picker-hidden {\n  pointer-events: none;\n  visibility: hidden;\n}\n\n.pn-msg {\n  align-items: var(--msg__alignItems);\n  display: flex;\n  flex-direction: var(--msg__flexDirection);\n  height: var(--msg__height);\n  padding: var(--msg__padding);\n  position: relative;\n}\n.pn-msg:hover {\n  background: var(--msg--hover__background);\n}\n.pn-msg:hover .pn-msg__actions {\n  display: flex;\n}\n.pn-msg__actions {\n  color: var(--msg__actions__color);\n  cursor: pointer;\n  display: none;\n  font-size: var(--msg__actions__fontSize);\n  position: absolute;\n  right: var(--msg__actions__right);\n  top: var(--msg__actions__top);\n}\n.pn-msg__actions > * {\n  background: var(--msg__actions__background);\n  border: var(--msg__actions__border);\n  border-radius: var(--msg__actions__borderRadius);\n  display: flex;\n  margin: var(--msg__actions__margin);\n  padding: var(--msg__actions__padding);\n}\n.pn-msg__actions > *:hover {\n  background: var(--msg__actions--hover__background);\n  border: var(--msg__actions--hover__border);\n  color: var(--msg__actions--hover__color);\n}\n.pn-msg__main {\n  align-items: var(--msg__main__alignItems);\n  display: flex;\n  flex-direction: var(--msg__main__flexDirection);\n  padding: var(--msg__main__margin);\n  max-width: var(--msg__main__maxWidth);\n}\n.pn-msg__content {\n  align-items: var(--msg__content__alignItems);\n  display: flex;\n  flex-direction: var(--msg__content__flexDirection);\n  padding: var(--msg__content__margin);\n}\n.pn-msg__title {\n  align-items: var(--msg__title__alignItems);\n  display: var(--msg__title__display);\n  margin: var(--msg__title__margin);\n}\n.pn-msg__bubble {\n  background: var(--msg__bubble__background);\n  box-shadow: var(--msg__bubble__boxShadow);\n  border-radius: var(--msg__bubble__borderRadius);\n  color: var(--msg__bubble__color);\n  display: inline-block;\n  font-size: var(--msg__bubble__fontSize);\n  font-weight: var(--msg__bubble__fontWeight);\n  margin: var(--msg__bubble__margin);\n  padding: var(--msg__bubble__padding);\n}\n.pn-msg__author {\n  color: var(--msg__author__color);\n  font-size: var(--msg__author__fontSize);\n  font-weight: var(--msg__author__fontWeight);\n  padding: var(--msg__author__padding);\n}\n.pn-msg__time {\n  display: var(--msg__time__display);\n  color: var(--msg__time__color);\n  font-size: var(--msg__time__fontSize);\n  font-weight: var(--msg__time__fontWeight);\n  padding: var(--msg__time__padding);\n}\n.pn-msg__avatar {\n  align-items: center;\n  border-radius: var(--msg__avatar__borderRadius);\n  color: var(--msg-list__background);\n  display: var(--msg__avatar__display);\n  font-size: var(--msg__avatar__fontSize);\n  height: var(--msg__avatar__size);\n  justify-content: center;\n  margin: var(--msg__avatar__margin);\n  width: var(--msg__avatar__size);\n}\n.pn-msg__avatar img {\n  border-radius: var(--msg__avatar__borderRadius);\n  height: 100%;\n  width: 100%;\n}\n.pn-msg__reaction {\n  background: var(--msg__reaction__background);\n  border: var(--msg__reaction__border);\n  border-radius: var(--msg__reaction__borderRadius);\n  color: var(--msg__bubble__color);\n  cursor: pointer;\n  display: inline-block;\n  font-size: var(--msg__bubble__fontSize);\n  font-weight: var(--msg__bubble__fontWeight);\n  margin: var(--msg__reaction__margin);\n  padding: var(--msg__reaction__padding);\n  word-spacing: var(--msg__reaction__wordSpacing);\n}\n.pn-msg__reaction:hover {\n  background: var(--msg__reaction--hover__background);\n  border: var(--msg__reaction--hover__border);\n}\n.pn-msg__reaction--active {\n  background: var(--msg__reaction--active__background);\n  border: var(--msg__reaction--active__border);\n}\n.pn-msg__reaction--active:hover {\n  background: var(--msg__reaction--active--hover__background);\n  border: var(--msg__reaction--active--hover__border);\n}\n.pn-msg__image {\n  border-radius: var(--msg__image__borderRadius);\n  box-shadow: var(--msg__bubble__boxShadow);\n  margin: var(--msg__image__margin);\n  max-width: 100%;\n}\n.pn-msg__link {\n  background: var(--msg__bubble__background);\n  border-radius: var(--msg__bubble__borderRadius);\n  box-shadow: var(--msg__bubble__boxShadow);\n  color: var(--msg__bubble__color);\n  display: flex;\n  font-size: var(--msg__bubble__fontSize);\n  font-weight: var(--msg__bubble__fontWeight);\n  margin: var(--msg__link__margin);\n  overflow: hidden;\n  text-decoration: none;\n}\n.pn-msg__link img {\n  max-width: var(--msg__link-thumb__maxWidth);\n}\n.pn-msg__link > div {\n  padding: var(--msg__link__padding);\n}\n.pn-msg__link-name {\n  font-size: 15px;\n  font-weight: 500;\n  margin: 0;\n}\n.pn-msg__link-name img {\n  margin-right: 10px;\n  max-height: 16px;\n  max-width: 16px;\n  vertical-align: bottom;\n}\n.pn-msg__link-title {\n  color: var(--msg__link-title__color);\n  font-weight: 500;\n  margin: 2px 0;\n}\n.pn-msg__link-description {\n  color: var(--msg__link-description__color);\n  margin: 0;\n}\n.pn-msg__nonImage {\n  color: var(--msg__bubble__color);\n}\n.pn-msg__downloadIcon {\n  color: var(--msg__bubble__color);\n  margin: 0 0 0 8px;\n  vertical-align: middle;\n}\n\n/* ************************\n** Themes\n** ********************* */\n.pn-msg-list--dark,\n.pn-msg-list--support-dark,\n.pn-msg-list--event-dark {\n  --msg-list__background: var(--chat--dark__background--1);\n  --msg-list__unread__background: var(--chat--dark__color--2);\n  --msg-list__unread__color: var(--chat--dark__background--2);\n  --msg-list__spinner__color: var(--chat--dark__color--2);\n  --msg--hover__background: var(--chat--dark__border--1);\n  --msg__actions--hover__color: var(--chat--dark__hover--1);\n  --msg__actions--hover__border: 1px solid var(--chat--dark__background--1);\n  --msg__actions--hover__background: var(--chat--dark__background--1);\n  --msg__actions__background: var(--chat--dark__background--1);\n  --msg__actions__border: 1px solid var(--chat--dark__background--1);\n  --msg__actions__color: var(--chat--dark__color--2);\n  --msg__author__color: var(--chat--dark__color--1);\n  --msg__bubble__color: var(--chat--dark__color--1);\n  --msg__link-description__color: var(--chat--dark__color--2);\n  --msg__link-title__color: var(--chat--dark__color--1);\n  --msg__time__color: var(--chat--dark__color--1);\n  --msg__reaction--hover__background: rgba(var(--chat--dark__hover--4-rgb), 0.3);\n  --msg__reaction--hover__border: 1px solid var(--chat--dark__hover--4);\n  --msg__reaction--active__background: rgba(var(--chat--dark__background--5), 0.3);\n  --msg__reaction--active--hover__background: rgba(var(--chat--dark__background--5), 0.4);\n  --msg__reaction--active--hover__border: 1px solid rgba(var(--chat--dark__background--5), 0.4);\n  --msg__reaction__background: var(--chat--dark__background--1);\n  --msg__reaction__border: 1px solid var(--chat--dark__border--1);\n}\n\n.pn-msg-list--support,\n.pn-msg-list--support-dark {\n  --msg__title__display: none;\n}\n.pn-msg-list--support .pn-msg--own,\n.pn-msg-list--support-dark .pn-msg--own {\n  --msg__flexDirection: row-reverse;\n  --msg__avatar__display: none;\n}\n\n.pn-msg-list--event,\n.pn-msg-list--event-dark {\n  --msg__alignItems: flex-start;\n  --msg__actions__top: 0;\n  --msg__author__fontSize: 13px;\n  --msg__avatar__display: none;\n  --msg__bubble__background: transparent;\n  --msg__bubble__padding: 0;\n  --msg__content__alignItems: center;\n  --msg__content__flexDirection: row;\n  --msg__main__alignItems: baseline;\n  --msg__main__flexDirection: column;\n  --msg__main__maxWidth: 100%;\n  --msg__padding: 7px 12px;\n  --msg__time__display: none;\n  --msg__title__margin: 0 6px 0 0;\n}\n.pn-msg-list--event .pn-msg__author:after,\n.pn-msg-list--event-dark .pn-msg__author:after {\n  content: ":";\n}';
styleInject(css_248z$3);
var MessageList = function(props) {
  var pubnub = usePubNub();
  var channel = jotai.useAtom(CurrentChannelAtom)[0];
  var users = jotai.useAtom(UsersMetaAtom)[0];
  var theme = jotai.useAtom(ThemeAtom)[0];
  var retryObj = jotai.useAtom(RetryFunctionAtom)[0];
  var onErrorObj = jotai.useAtom(ErrorFunctionAtom)[0];
  var messages = jotai.useAtom(CurrentChannelMessagesAtom)[0];
  var paginationEnd = jotai.useAtom(CurrentChannelPaginationAtom)[0];
  var retry = retryObj.function;
  var onError = onErrorObj.function;
  var _a = (0, import_react.useState)(true), scrolledBottom = _a[0], setScrolledBottom = _a[1];
  var _b = (0, import_react.useState)([]), prevMessages = _b[0], setPrevMessages = _b[1];
  var _c = (0, import_react.useState)(0), unreadMessages = _c[0], setUnreadMessages = _c[1];
  var _d = (0, import_react.useState)(false), fetchingMessages = _d[0], setFetchingMessages = _d[1];
  var _e = (0, import_react.useState)(), picker = _e[0], setPicker = _e[1];
  var _f = (0, import_react.useState)(false), emojiPickerShown = _f[0], setEmojiPickerShown = _f[1];
  var _g = (0, import_react.useState)(null), reactingToMessage = _g[0], setReactingToMessage = _g[1];
  var endRef = (0, import_react.useRef)(null);
  var listRef = (0, import_react.useRef)(null);
  var spinnerRef = (0, import_react.useRef)(null);
  var pickerRef = useOuterClick(function(event2) {
    if (event2.target.closest(".pn-msg__reactions-toggle"))
      return;
    setEmojiPickerShown(false);
  });
  var spinnerObserver = (0, import_react.useRef)(new IntersectionObserver(function(e) {
    return e[0].isIntersecting === true && fetchMoreHistory();
  }));
  var bottomObserver = (0, import_react.useRef)(new IntersectionObserver(function(e) {
    return handleBottomScroll(e[0].isIntersecting);
  }));
  var getTime = function(timestamp) {
    var ts = String(timestamp);
    var date = new Date(parseInt(ts) / 1e4);
    var formatter = new Intl.DateTimeFormat([], { timeStyle: "short" });
    return formatter.format(date);
  };
  var scrollToBottom = function() {
    if (!endRef.current)
      return;
    endRef.current.scrollIntoView({ behavior: "smooth", block: "nearest" });
  };
  var setupSpinnerObserver = function() {
    if (!spinnerRef.current)
      return;
    spinnerObserver.current.observe(spinnerRef.current);
  };
  var setupBottomObserver = function() {
    if (!endRef.current)
      return;
    bottomObserver.current.disconnect();
    bottomObserver.current.observe(endRef.current);
  };
  var getUser = function(uuid) {
    return users.find(function(u) {
      return u.id === uuid;
    });
  };
  var isOwnMessage = function(uuid) {
    return pubnub.getUUID() === uuid;
  };
  var fetchHistory = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var history_1, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!props.fetchMessages)
              return [2];
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, 4, 5]);
            setFetchingMessages(true);
            return [4, retry(function() {
              return pubnub.fetchMessages({
                channels: [channel],
                count: props.fetchMessages,
                includeMessageActions: true
              });
            })];
          case 2:
            history_1 = _a2.sent();
            handleHistoryFetch(history_1);
            scrollToBottom();
            setupSpinnerObserver();
            setupBottomObserver();
            return [3, 5];
          case 3:
            e_1 = _a2.sent();
            onError(e_1);
            return [3, 5];
          case 4:
            setFetchingMessages(false);
            return [7];
          case 5:
            return [2];
        }
      });
    });
  };
  var fetchMoreHistory = utils.useAtomCallback((0, import_react.useCallback)(function(get) {
    return __awaiter(void 0, void 0, void 0, function() {
      var channel2, retryObj2, errorObj, messages2, retry2, onError2, firstMessage, history_2, e_2;
      var _a2;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            channel2 = get(CurrentChannelAtom);
            retryObj2 = get(RetryFunctionAtom);
            errorObj = get(ErrorFunctionAtom);
            messages2 = get(CurrentChannelMessagesAtom);
            retry2 = retryObj2.function;
            onError2 = errorObj.function;
            firstMessage = (_a2 = listRef.current) === null || _a2 === void 0 ? void 0 : _a2.querySelector(".pn-msg");
            if (!messages2.length)
              return [2];
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, 3, , 4]);
            return [4, retry2(function() {
              return pubnub.fetchMessages({
                channels: [channel2],
                count: props.fetchMessages,
                start: (messages2 === null || messages2 === void 0 ? void 0 : messages2[0].timetoken) || void 0,
                includeMessageActions: true
              });
            })];
          case 2:
            history_2 = _b2.sent();
            handleHistoryFetch(history_2);
            if (firstMessage)
              firstMessage.scrollIntoView();
            return [3, 4];
          case 3:
            e_2 = _b2.sent();
            onError2(e_2);
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  }, []));
  var addReaction = function(reaction, messageTimetoken) {
    try {
      pubnub.addMessageAction({
        channel,
        messageTimetoken,
        action: {
          type: "reaction",
          value: reaction
        }
      });
    } catch (e) {
      onError(e);
    }
  };
  var removeReaction = function(reaction, messageTimetoken, actionTimetoken) {
    try {
      pubnub.removeMessageAction({ channel, messageTimetoken, actionTimetoken });
    } catch (e) {
      onError(e);
    }
  };
  var fetchFileUrl = function(envelope) {
    if (!isFileMessage(envelope.message))
      return envelope;
    try {
      var url = pubnub.getFileUrl({
        channel: envelope.channel,
        id: envelope.message.file.id,
        name: envelope.message.file.name
      });
      envelope.message.file.url = url;
    } catch (e) {
      onError(e);
    } finally {
      return envelope;
    }
  };
  var handleEmojiInsertion = (0, import_react.useCallback)(function(emoji) {
    try {
      if (!("native" in emoji))
        return;
      addReaction(emoji.native, reactingToMessage);
      setEmojiPickerShown(false);
    } catch (e) {
      onError(e);
    }
  }, [reactingToMessage]);
  var handleBottomScroll = function(scrolledBottom2) {
    try {
      if (scrolledBottom2)
        setUnreadMessages(0);
      setScrolledBottom(scrolledBottom2);
    } catch (e) {
      onError(e);
    }
  };
  var handleHistoryFetch = utils.useAtomCallback((0, import_react.useCallback)(function(get, set2, response) {
    var channel2 = get(CurrentChannelAtom);
    var messages2 = get(CurrentChannelMessagesAtom);
    var newMessages = ((response === null || response === void 0 ? void 0 : response.channels[channel2]) || []).map(function(m) {
      return m.messageType === 4 ? fetchFileUrl(m) : m;
    }) || [];
    var allMessages = __spreadArray(__spreadArray([], messages2), newMessages).sort(function(a, b) {
      return a.timetoken - b.timetoken;
    });
    setEmojiPickerShown(false);
    setPrevMessages(allMessages);
    set2(CurrentChannelMessagesAtom, allMessages);
    set2(CurrentChannelPaginationAtom, !allMessages.length || newMessages.length !== props.fetchMessages);
  }, []));
  var handleOpenReactions = function(event2, timetoken) {
    try {
      var newPickerTopPosition = listRef.current.scrollTop - listRef.current.getBoundingClientRect().top + event2.target.getBoundingClientRect().y;
      if (newPickerTopPosition > pickerRef.current.offsetHeight) {
        newPickerTopPosition += event2.target.getBoundingClientRect().height;
        newPickerTopPosition -= pickerRef.current.offsetHeight;
      }
      pickerRef.current.style.top = newPickerTopPosition + "px";
      setEmojiPickerShown(true);
      setReactingToMessage(timetoken);
    } catch (e) {
      onError(e);
    }
  };
  (0, import_react.useEffect)(function() {
    if (!pubnub || !channel)
      return;
    if (!(messages === null || messages === void 0 ? void 0 : messages.length))
      fetchHistory();
    setupSpinnerObserver();
  }, [channel]);
  (0, import_react.useEffect)(function() {
    if (import_react.default.isValidElement(props.reactionsPicker)) {
      setPicker(import_react.default.cloneElement(props.reactionsPicker, { onSelect: handleEmojiInsertion }));
    }
  }, [props.reactionsPicker, handleEmojiInsertion]);
  (0, import_react.useEffect)(function() {
    if (!(messages === null || messages === void 0 ? void 0 : messages.length))
      return;
    var messagesFromListener = messages.length - prevMessages.length;
    if (scrolledBottom)
      scrollToBottom();
    if (!scrolledBottom && messagesFromListener)
      setUnreadMessages(unreadMessages + messagesFromListener);
    setupBottomObserver();
    setPrevMessages(messages);
  }, [messages]);
  var renderWelcomeMessages = function() {
    if (!props.welcomeMessages)
      return;
    return Array.isArray(props.welcomeMessages) ? props.welcomeMessages.map(function(m) {
      return renderItem(m);
    }) : renderItem(props.welcomeMessages);
  };
  var renderItem = function(envelope) {
    var uuid = envelope.uuid || envelope.publisher || "";
    var currentUserClass = isOwnMessage(uuid) ? "pn-msg--own" : "";
    var actions = envelope.actions;
    var deleted = !!Object.keys((actions === null || actions === void 0 ? void 0 : actions.deleted) || {}).length;
    var message = isFileMessage(envelope.message) ? envelope.message.message : envelope.message;
    if (deleted)
      return;
    return import_react.default.createElement("div", { className: "pn-msg " + currentUserClass, key: envelope.timetoken }, renderMessage(envelope), import_react.default.createElement("div", { className: "pn-msg__actions" }, props.extraActionsRenderer && props.extraActionsRenderer(envelope), props.reactionsPicker && (message === null || message === void 0 ? void 0 : message.type) !== "welcome" && import_react.default.createElement("div", { className: "pn-msg__reactions-toggle", title: "Add a reaction", onClick: function(e) {
      emojiPickerShown && reactingToMessage === envelope.timetoken ? setEmojiPickerShown(false) : handleOpenReactions(e, envelope.timetoken);
    } }, import_react.default.createElement(SvgEmoji, null))));
  };
  var renderMessage = function(envelope) {
    var uuid = envelope.uuid || envelope.publisher || "";
    var time = getTime(envelope.timetoken);
    var isOwn = isOwnMessage(uuid);
    var message = isFileMessage(envelope.message) ? envelope.message.message : envelope.message;
    var user = (message === null || message === void 0 ? void 0 : message.sender) || getUser(uuid);
    var attachments = (message === null || message === void 0 ? void 0 : message.attachments) || [];
    var file = isFileMessage(envelope.message) && envelope.message.file;
    var actions = envelope.actions;
    var editedText = (Object.entries((actions === null || actions === void 0 ? void 0 : actions.updated) || {}).pop() || []).shift();
    if (props.messageRenderer && (props.filter ? props.filter(envelope) : true))
      return props.messageRenderer({ message: envelope, user, time, isOwn, editedText });
    return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement("div", { className: "pn-msg__avatar", style: { backgroundColor: getPredefinedColor(uuid) } }, (user === null || user === void 0 ? void 0 : user.profileUrl) ? import_react.default.createElement("img", { src: user.profileUrl, alt: "User avatar" }) : getNameInitials((user === null || user === void 0 ? void 0 : user.name) || uuid)), import_react.default.createElement("div", { className: "pn-msg__main" }, import_react.default.createElement("div", { className: "pn-msg__content" }, import_react.default.createElement("div", { className: "pn-msg__title" }, import_react.default.createElement("span", { className: "pn-msg__author" }, (user === null || user === void 0 ? void 0 : user.name) || uuid), import_react.default.createElement("span", { className: "pn-msg__time" }, time)), (message === null || message === void 0 ? void 0 : message.text) && (props.bubbleRenderer && (props.filter ? props.filter(envelope) : true) ? props.bubbleRenderer({ message: envelope, user, time, isOwn, editedText }) : import_react.default.createElement("div", { className: "pn-msg__bubble" }, editedText || (message === null || message === void 0 ? void 0 : message.text)))), import_react.default.createElement("div", { className: "pn-msg__extras" }, file && file.name && renderFile(file), attachments.map(renderAttachment), props.enableReactions && renderReactions(envelope))));
  };
  var renderReactions = function(envelope) {
    var _a2;
    var reactions = (_a2 = envelope.actions) === null || _a2 === void 0 ? void 0 : _a2.reaction;
    if (!reactions)
      return;
    return import_react.default.createElement("div", { className: "pn-msg__reactions" }, Object.keys(reactions).map(function(reaction) {
      var instances = reactions[reaction];
      var userReaction = instances === null || instances === void 0 ? void 0 : instances.find(function(i) {
        return i.uuid === pubnub.getUUID();
      });
      return import_react.default.createElement("div", { className: "pn-msg__reaction " + (userReaction ? "pn-msg__reaction--active" : ""), key: reaction, onClick: function() {
        userReaction ? removeReaction(reaction, envelope.timetoken, userReaction.actionTimetoken) : addReaction(reaction, envelope.timetoken);
      } }, reaction, " ", instances.length);
    }));
  };
  var renderFile = function(file) {
    return import_react.default.createElement("div", { className: "pn-msg__file" }, /\.(svg|gif|jpe?g|tiff?|png|webp|bmp)$/i.test(file.name) ? import_react.default.createElement("img", { alt: file.name, className: "pn-msg__image", src: file.url, onLoad: function() {
      if (scrolledBottom)
        scrollToBottom();
    } }) : import_react.default.createElement("div", { className: "pn-msg__bubble" }, import_react.default.createElement("a", { className: "pn-msg__nonImage", href: file.url, target: "_blank", rel: "noopener noreferrer", download: true }, file.name, import_react.default.createElement(SvgDownload, { className: "pn-msg__downloadIcon" }))));
  };
  var renderAttachment = function(attachment, key) {
    var _a2, _b2, _c2, _d2, _e2;
    return import_react.default.createElement("div", { key, className: "pn-msg__attachments" }, attachment.type === "image" && import_react.default.createElement("img", { className: "pn-msg__image", src: (_a2 = attachment.image) === null || _a2 === void 0 ? void 0 : _a2.source }), attachment.type === "link" && import_react.default.createElement("a", { className: "pn-msg__link", href: (_b2 = attachment.provider) === null || _b2 === void 0 ? void 0 : _b2.url, target: "_blank", rel: "noreferrer noopener" }, import_react.default.createElement("img", { src: (_c2 = attachment.image) === null || _c2 === void 0 ? void 0 : _c2.source }), import_react.default.createElement("div", null, import_react.default.createElement("p", { className: "pn-msg__link-name" }, import_react.default.createElement("img", { src: (_d2 = attachment.icon) === null || _d2 === void 0 ? void 0 : _d2.source }), (_e2 = attachment.provider) === null || _e2 === void 0 ? void 0 : _e2.name), import_react.default.createElement("p", { className: "pn-msg__link-title" }, attachment.title), import_react.default.createElement("p", { className: "pn-msg__link-description" }, attachment.description))));
  };
  return import_react.default.createElement("div", { className: "pn-msg-list pn-msg-list--" + theme }, unreadMessages > 0 && import_react.default.createElement("div", { className: "pn-msg-list__unread", onClick: function() {
    return scrollToBottom();
  } }, unreadMessages, " new message", unreadMessages > 1 ? "s" : "", " ", import_react.default.createElement(SvgArrowDown, null)), import_react.default.createElement("div", { className: "pn-msg-list-scroller", onScroll: props.onScroll, ref: listRef }, !!props.fetchMessages && !paginationEnd && import_react.default.createElement("span", { ref: spinnerRef, className: "pn-msg-list__spinner" }, import_react.default.createElement(SvgSpinner, null)), import_react.default.createElement("div", { className: "pn-msg-list__spacer" }), (!props.fetchMessages || !fetchingMessages && !messages.length) && renderWelcomeMessages(), messages && messages.map(function(m) {
    return renderItem(m);
  }), props.children, import_react.default.createElement("div", { className: "pn-msg-list__bottom-ref", ref: endRef }), props.reactionsPicker && import_react.default.createElement("div", { className: "pn-msg-list__emoji-picker " + (!emojiPickerShown && "pn-msg-list__emoji-picker-hidden"), ref: pickerRef }, picker)));
};
MessageList.defaultProps = {
  enableReactions: false,
  fetchMessages: 0
};
var css_248z$2 = "/* ************************\n** Variables\n** ********************* */\n:root {\n  --member-list__background: transparent;\n  --member__alignItems: center;\n  --member__cursor: auto;\n  --member__padding: 8px 16px;\n  --member__background: transparent;\n  --member--hover__background: transparent;\n  --member__avatar__color: var(--chat--light__background--2);\n  --member__avatar__display: flex;\n  --member__avatar__fontSize: 10px;\n  --member__avatar__margin: 0 18px 0 0;\n  --member__avatar__size: 36px;\n  --member__avatar__borderRadius: 36px;\n  --member__name__color: var(--chat--light__color--1);\n  --member__name__fontSize: 13px;\n  --member__name__fontWeight: 400;\n  --member__name__padding: 0;\n  --member__name__margin: 0;\n  --member__title__color: var(--chat--light__color--2);\n  --member__title__display: inline-block;\n  --member__title__fontSize: 11px;\n  --member__title__fontWeight: 400;\n  --member__title__padding: 7px 0 0;\n  --member__title__margin: 0;\n  --member__presence__border: 3px solid var(--chat--light__background--2);\n  --member__presence__borderRadius: 100%;\n  --member__presence__color: var(--chat--light__background--4);\n  --member__presence__left: 48px;\n  --member__presence__position: absolute;\n  --member__presence__size: 8px;\n  --member__presence__top: 34px;\n  --member__actions--hover__background: transparent;\n  --member__actions__background: transparent;\n  --member__actions__borderRadius: 5px;\n  --member__actions__color: var(--chat--light__color--2);\n  --member__actions--hover__color: var(--chat--light__hover--1);\n  --member__actions__fontSize: 18px;\n  --member__actions__margin: 0 0 0 4px;\n  --member__actions__padding: 3px 5px;\n}\n\n/* ************************\n** Styles\n** ********************* */\n.pn-member-list {\n  height: 100%;\n  overflow-y: auto;\n  width: 100%;\n  background: var(--member-list__background);\n}\n\n.pn-member {\n  align-items: var(--member__alignItems);\n  background: var(--member__background);\n  cursor: var(--member__cursor);\n  display: flex;\n  padding: var(--member__padding);\n  position: relative;\n}\n.pn-member:hover {\n  background: var(--member--hover__background);\n}\n.pn-member:hover .pn-member__actions {\n  visibility: visible;\n}\n.pn-member__avatar {\n  align-items: center;\n  border-radius: var(--member__avatar__borderRadius);\n  color: var(--member__avatar__color);\n  display: var(--member__avatar__display);\n  font-size: var(--member__avatar__fontSize);\n  height: var(--member__avatar__size);\n  justify-content: center;\n  margin: var(--member__avatar__margin);\n  width: var(--member__avatar__size);\n}\n.pn-member__avatar img {\n  border-radius: var(--member__avatar__borderRadius);\n  height: 100%;\n  width: 100%;\n}\n.pn-member__main {\n  flex: 1;\n}\n.pn-member__name {\n  color: var(--member__name__color);\n  font-size: var(--member__name__fontSize);\n  font-weight: var(--member__name__fontWeight);\n  margin: var(--member__name__margin);\n  padding: var(--member__name__padding);\n  text-align: left;\n}\n.pn-member__title {\n  color: var(--member__title__color);\n  display: var(--member__title__display);\n  font-size: var(--member__title__fontSize);\n  font-weight: var(--member__title__fontWeight);\n  margin: var(--member__title__margin);\n  padding: var(--member__title__padding);\n  text-align: left;\n}\n.pn-member__presence {\n  background: var(--member__presence__color);\n  border: var(--member__presence__border);\n  border-radius: var(--member__presence__borderRadius);\n  height: var(--member__presence__size);\n  left: var(--member__presence__left);\n  position: var(--member__presence__position);\n  top: var(--member__presence__top);\n  width: var(--member__presence__size);\n}\n.pn-member__actions {\n  color: var(--member__actions__color);\n  cursor: pointer;\n  display: flex;\n  visibility: hidden;\n  font-size: var(--member__actions__fontSize);\n}\n.pn-member__actions > * {\n  background: var(--member__actions__background);\n  border-radius: var(--member__actions__borderRadius);\n  display: flex;\n  margin: var(--member__actions__margin);\n  padding: var(--member__actions__padding);\n}\n.pn-member__actions > *:hover {\n  background: var(--member__actions--hover__background);\n  color: var(--member__actions--hover__color);\n}\n\n/* ************************\n** Themes\n** ********************* */\n.pn-member-list--dark,\n.pn-member-list--event-dark,\n.pn-member-list--support-dark {\n  --member-list__background: var(--chat--dark__background--2);\n  --member__avatar__color: var(--chat--dark__background--2);\n  --member__name__color: var(--chat--dark__color--1);\n  --member__title__color: var(--chat--dark__color--2);\n  --member__presence__border: 3px solid var(--chat--dark__background--2);\n  --member__presence__color: var(--chat--dark__background--4);\n  --member__actions__color: var(--chat--dark__color--2);\n  --member__actions--hover__color: var(--chat--dark__hover--1);\n}";
styleInject(css_248z$2);
var MemberList = function(props) {
  var pubnub = usePubNub();
  var theme = jotai.useAtom(ThemeAtom)[0];
  var isOwnMember = function(uuid) {
    return pubnub.getUUID() === uuid;
  };
  var isPresentMember = function(uuid) {
    return props.presentMembers.includes(uuid);
  };
  var memberSorter = function(a, b) {
    if (isOwnMember(a.id))
      return -1;
    if (isOwnMember(b.id))
      return 1;
    if (isPresentMember(a.id) && !isPresentMember(b.id))
      return -1;
    if (isPresentMember(b.id) && !isPresentMember(a.id))
      return 1;
    return a.name.localeCompare(b.name, "en", { sensitivity: "base" });
  };
  var memberFromString = function(member) {
    if (typeof member === "string") {
      return {
        id: member,
        name: member
      };
    }
    return member;
  };
  var clickMember = function(member) {
    if (props.onMemberClicked)
      props.onMemberClicked(member);
  };
  var renderMember = function(member) {
    var _a;
    if (props.memberRenderer)
      return props.memberRenderer(member);
    var youString = isOwnMember(member.id) ? props.selfText : "";
    return import_react.default.createElement("div", { key: member.id, className: "pn-member", onClick: function() {
      return clickMember(member);
    } }, import_react.default.createElement("div", { className: "pn-member__avatar", style: { backgroundColor: getPredefinedColor(member.id) } }, member.profileUrl ? import_react.default.createElement("img", { src: member.profileUrl, alt: "User avatar" }) : getNameInitials(member.name || member.id), isPresentMember(member.id) && import_react.default.createElement("i", { className: "pn-member__presence" })), import_react.default.createElement("div", { className: "pn-member__main" }, import_react.default.createElement("p", { className: "pn-member__name" }, member.name, " ", youString), import_react.default.createElement("p", { className: "pn-member__title" }, (_a = member.custom) === null || _a === void 0 ? void 0 : _a.title)), import_react.default.createElement("div", { className: "pn-member__actions" }, props.extraActionsRenderer && props.extraActionsRenderer(member)));
  };
  return import_react.default.createElement("div", { className: "pn-member-list pn-member-list--" + theme }, props.members.map(memberFromString).sort(memberSorter).map(renderMember), import_react.default.createElement(import_react.default.Fragment, null, props.children));
};
MemberList.defaultProps = {
  members: [],
  presentMembers: [],
  onMemberClicked: null,
  selfText: "(You)"
};
var css_248z$1 = "/* ************************\n** Variables\n** ********************* */\n:root {\n  --channel-list__background: var(--chat--light__background--2);\n  --channel__alignItems: center;\n  --channel__padding: 8px 16px;\n  --channel__justifyContent: flex-start;\n  --channel__background: transparent;\n  --channel--hover__background: var(--chat--light__hover--2);\n  --channel--active__background: var(--chat--light__background--1);\n  --channel__thumb__display: block;\n  --channel__thumb__margin: 0 18px 0 0;\n  --channel__thumb__size: 36px;\n  --channel__thumb__borderRadius: 36px;\n  --channel__name__color: var(--chat--light__color--1);\n  --channel--hover__name__color: var(--chat--light__color--1);\n  --channel--active__name__color: var(--chat--light__color--1);\n  --channel__name__fontSize: 13px;\n  --channel__name__fontWeight: 400;\n  --channel__name__padding: 0;\n  --channel__name__margin: 0;\n  --channel__description__color: var(--chat--light__color--2);\n  --channel--hover__description__color: var(--chat--light__color--2);\n  --channel--active__description__color: var(--chat--light__color--2);\n  --channel__description__display: inline-block;\n  --channel__description__fontSize: 11px;\n  --channel__description__fontWeight: 400;\n  --channel__description__padding: 7px 0 0;\n  --channel__description__margin: 0;\n  --channel__actions--hover__background: transparent;\n  --channel__actions__background: transparent;\n  --channel__actions__borderRadius: 5px;\n  --channel__actions__color: var(--chat--light__color--2);\n  --channel__actions--hover__color: var(--chat--light__hover--1);\n  --channel__actions__fontSize: 18px;\n  --channel__actions__margin: 0 0 0 4px;\n  --channel__actions__padding: 3px 5px;\n}\n\n/* ************************\n** Styles\n** ********************* */\n.pn-channel-list {\n  height: 100%;\n  overflow-y: auto;\n  width: 100%;\n  background: var(--channel-list__background);\n}\n\n.pn-channel {\n  align-items: var(--channel__alignItems);\n  background: var(--channel__background);\n  cursor: pointer;\n  display: flex;\n  justify-content: var(--channel__justifyContent);\n  padding: var(--channel__padding);\n  position: relative;\n}\n.pn-channel:hover {\n  background: var(--channel--hover__background);\n}\n.pn-channel:hover .pn-channel__leave {\n  display: inline;\n}\n.pn-channel:hover .pn-channel__name {\n  color: var(--channel--hover__name__color);\n}\n.pn-channel:hover .pn-channel__description {\n  color: var(--channel--hover__description__color);\n}\n.pn-channel:hover .pn-channel__actions {\n  visibility: visible;\n}\n.pn-channel--active {\n  background: var(--channel--active__background);\n}\n.pn-channel--active .pn-channel__name {\n  color: var(--channel--active__name__color);\n}\n.pn-channel--active .pn-channel__description {\n  color: var(--channel--active__description__color);\n}\n.pn-channel__thumb {\n  border-radius: var(--channel__thumb__borderRadius);\n  display: var(--channel__thumb__display);\n  margin: var(--channel__thumb__margin);\n  width: var(--channel__thumb__size);\n}\n.pn-channel__title {\n  flex: 1;\n}\n.pn-channel__name {\n  color: var(--channel__name__color);\n  font-size: var(--channel__name__fontSize);\n  font-weight: var(--channel__name__fontWeight);\n  margin: var(--channel__name__margin);\n  padding: var(--channel__name__padding);\n  text-align: left;\n  word-break: break-word;\n}\n.pn-channel__description {\n  color: var(--channel__description__color);\n  display: var(--channel__description__display);\n  font-size: var(--channel__description__fontSize);\n  font-weight: var(--channel__description__fontWeight);\n  margin: var(--channel__description__margin);\n  padding: var(--channel__description__padding);\n  text-align: left;\n}\n.pn-channel__actions {\n  color: var(--channel__actions__color);\n  cursor: pointer;\n  display: flex;\n  visibility: hidden;\n  font-size: var(--channel__actions__fontSize);\n}\n.pn-channel__actions > * {\n  background: var(--channel__actions__background);\n  border-radius: var(--channel__actions__borderRadius);\n  display: flex;\n  margin: var(--channel__actions__margin);\n  padding: var(--channel__actions__padding);\n}\n.pn-channel__actions > *:hover {\n  background: var(--channel__actions--hover__background);\n  color: var(--channel__actions--hover__color);\n}\n.pn-channel__leave {\n  color: var(--channel__leave__color);\n  display: none;\n  height: var(--channel__leave__size);\n  position: absolute;\n  right: var(--channel__leave__right);\n  top: var(--channel__leave__top);\n  width: var(--channel__leave__size);\n}\n\n/* ************************\n** Themes\n** ********************* */\n.pn-channel-list--dark,\n.pn-channel-list--event-dark,\n.pn-channel-list--support-dark {\n  --channel-list__background: var(--chat--dark__background--2);\n  --channel--hover__background: var(--chat--dark__hover--2);\n  --channel--active__background: var(--chat--dark__background--1);\n  --channel__name__color: var(--chat--dark__color--1);\n  --channel--hover__name__color: var(--chat--dark__color--1);\n  --channel--active__name__color: var(--chat--dark__color--1);\n  --channel__description__color: var(--chat--dark__color--2);\n  --channel--hover__description__color: var(--chat--dark__color--2);\n  --channel--active__description__color: var(--chat--dark__color--2);\n  --channel__actions__color: var(--chat--dark__color--2);\n  --channel__actions--hover__color: var(--chat--dark__hover--1);\n}";
styleInject(css_248z$1);
var ChannelList = function(props) {
  var currentChannel = jotai.useAtom(CurrentChannelAtom)[0];
  var theme = jotai.useAtom(ThemeAtom)[0];
  var isChannelActive = function(ch) {
    return currentChannel === ch.id;
  };
  var channelSorter = function(a, b) {
    var _a;
    return (_a = a === null || a === void 0 ? void 0 : a.name) === null || _a === void 0 ? void 0 : _a.localeCompare(b.name, "en", { sensitivity: "base" });
  };
  var channelFromString = function(channel) {
    if (typeof channel === "string") {
      return {
        id: channel,
        name: channel
      };
    }
    return channel;
  };
  var switchChannel = function(channel) {
    if (props.onChannelSwitched)
      props.onChannelSwitched(channel);
  };
  var renderChannel = function(channel) {
    var _a, _b;
    if (props.channelRenderer)
      return props.channelRenderer(channel);
    var channelActive = isChannelActive(channel);
    var activeClass = channelActive ? "pn-channel--active" : "";
    return import_react.default.createElement("div", { key: channel.id, className: "pn-channel " + activeClass, onClick: function() {
      return switchChannel(channel);
    } }, ((_a = channel.custom) === null || _a === void 0 ? void 0 : _a.thumb) && import_react.default.createElement("img", { className: "pn-channel__thumb", src: (_b = channel.custom) === null || _b === void 0 ? void 0 : _b.thumb, alt: "Channel thumb" }), import_react.default.createElement("div", { className: "pn-channel__title" }, import_react.default.createElement("p", { className: "pn-channel__name" }, channel.name || channel.id), channel.description && import_react.default.createElement("p", { className: "pn-channel__description" }, channel.description)), import_react.default.createElement("div", { className: "pn-channel__actions" }, props.extraActionsRenderer && props.extraActionsRenderer(channel)));
  };
  return import_react.default.createElement("div", { className: "pn-channel-list pn-channel-list--" + theme }, props.channels.map(channelFromString).sort(channelSorter).map(renderChannel), import_react.default.createElement(import_react.default.Fragment, null, props.children));
};
var lodash_isequal = createCommonjsModule(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var reIsNative2 = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString = toSource2(DataView), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set2), weakMapCtorString = toSource2(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache2();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED2);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData2(map, key) {
    var data = map.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex2(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual;
});
var css_248z = "/* ************************\n** Variables\n** ********************* */\n:root {\n  --typing-indicator__background: var(--chat--light__background--1);\n  --typing-indicator__color: var(--chat--light__color--1);\n  --typing-indicator__display: inline-block;\n  --typing-indicator__fontSize: 11px;\n  --typing-indicator__fontWeight: 300;\n  --typing-indicator__padding: 8px 24px;\n  --typing-indicator__dot__fontSize: 8px;\n  --typing-indicator__dot__margin: 0 3px 0 0;\n  --typing-indicator__dot__animationTravel: -12px;\n  --typing-indicator__dot__animationDuration: 1.3s;\n  --typing-indicator__dot__animationTimeout1: -1.1s;\n  --typing-indicator__dot__animationTimeout2: -0.9s;\n}\n\n/* ************************\n** Styles\n** ********************* */\n.pn-typing-indicator {\n  background: var(--typing-indicator__background);\n  color: var(--typing-indicator__color);\n  display: var(--typing-indicator__display);\n  font-size: var(--typing-indicator__fontSize);\n  font-weight: var(--typing-indicator__fontWeight);\n  padding: var(--typing-indicator__padding);\n}\n\n.pn-typing-indicator-dot {\n  display: inline-block;\n  font-size: var(--typing-indicator__dot__fontSize);\n  margin: var(--typing-indicator__dot__margin);\n  animation: wave var(--typing-indicator__dot__animationDuration) linear infinite;\n}\n.pn-typing-indicator-dot:nth-child(2) {\n  animation-delay: var(--typing-indicator__dot__animationTimeout1);\n}\n.pn-typing-indicator-dot:nth-child(3) {\n  animation-delay: var(--typing-indicator__dot__animationTimeout2);\n}\n\n@keyframes wave {\n  0%, 60%, 100% {\n    transform: initial;\n  }\n  30% {\n    transform: translateY(var(--typing-indicator__dot__animationTravel));\n  }\n}\n.pn-typing-indicator--dark,\n.pn-typing-indicator--event-dark,\n.pn-typing-indicator--support-dark {\n  --typing-indicator__background: var(--chat--dark__background--1);\n  --typing-indicator__color: var(--chat--dark__color--1);\n}";
styleInject(css_248z);
var TypingIndicator = function(props) {
  var theme = jotai.useAtom(ThemeAtom)[0];
  var users = jotai.useAtom(UsersMetaAtom)[0];
  var typingIndicators = jotai.useAtom(CurrentChannelTypingIndicatorAtom)[0];
  var typingIndicatorTimeout = jotai.useAtom(TypingIndicatorTimeoutAtom)[0];
  var _a = (0, import_react.useState)([]), activeUUIDs = _a[0], setActiveUUIDs = _a[1];
  var typingIndicatorsRef = (0, import_react.useRef)(typingIndicators);
  if (!lodash_isequal(typingIndicatorsRef.current, typingIndicators)) {
    typingIndicatorsRef.current = typingIndicators;
  }
  var calculateActiveUUIDs = (0, import_react.useCallback)(function() {
    var currentActiveUUIDs = Object.keys(typingIndicators).filter(function(id) {
      return Date.now() - parseInt(typingIndicators[id]) / 1e4 < typingIndicatorTimeout * 1e3;
    });
    setActiveUUIDs(currentActiveUUIDs);
  }, [typingIndicatorsRef.current]);
  var getIndicationString = function() {
    var indicateStr = "";
    if (activeUUIDs.length > 1)
      indicateStr = "Multiple users are typing...";
    if (activeUUIDs.length == 1) {
      var user = users.find(function(u) {
        return u.id === activeUUIDs[0];
      });
      indicateStr = ((user === null || user === void 0 ? void 0 : user.name) || "Unknown User") + " is typing...";
    }
    return indicateStr;
  };
  (0, import_react.useEffect)(function() {
    calculateActiveUUIDs();
    var interval = setInterval(calculateActiveUUIDs, 1e3);
    return function() {
      return clearInterval(interval);
    };
  }, [calculateActiveUUIDs]);
  var renderUserBubble = function(uuid) {
    var user = users.find(function(u) {
      return u.id === uuid;
    });
    return import_react.default.createElement("div", { className: "pn-msg", key: uuid }, import_react.default.createElement("div", { className: "pn-msg__avatar" }, (user === null || user === void 0 ? void 0 : user.profileUrl) && import_react.default.createElement("img", { src: user.profileUrl, alt: "User avatar" }), !(user === null || user === void 0 ? void 0 : user.profileUrl) && import_react.default.createElement("div", { className: "pn-msg__avatar-placeholder" })), import_react.default.createElement("div", { className: "pn-msg__main" }, import_react.default.createElement("div", { className: "pn-msg__title" }, import_react.default.createElement("span", { className: "pn-msg__author" }, (user === null || user === void 0 ? void 0 : user.name) || "Unknown User")), import_react.default.createElement("div", { className: "pn-msg__bubble" }, import_react.default.createElement("span", { className: "pn-typing-indicator-dot" }, "\u25CF"), import_react.default.createElement("span", { className: "pn-typing-indicator-dot" }, "\u25CF"), import_react.default.createElement("span", { className: "pn-typing-indicator-dot" }, "\u25CF"))));
  };
  return import_react.default.createElement(import_react.default.Fragment, null, !props.showAsMessage && !!activeUUIDs.length && import_react.default.createElement("div", { className: "pn-typing-indicator pn-typing-indicator--" + theme }, getIndicationString(), "\xA0"), props.showAsMessage && activeUUIDs.map(function(uuid) {
    return renderUserBubble(uuid);
  }));
};
TypingIndicator.defaultProps = {
  showAsMessage: false
};
var lodash_merge = createCommonjsModule(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var objectCtorString = funcToString2.call(Object);
  var reIsNative2 = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array = root2.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
  var Map2 = getNative2(root2, "Map"), nativeCreate2 = getNative2(Object, "create");
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function Hash2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq2(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assignValue2(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  var baseFor = createBaseFor();
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeysIn(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject2(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue2(object, key, newValue);
      }
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function getMapData2(map, key) {
    var data = map.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function isIndex2(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex2(index, object.length) : type == "string" && index in object) {
      return eq2(object[index], value);
    }
    return false;
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  var setToString = shortOut(baseSetToString);
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var merge = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  function constant(value) {
    return function() {
      return value;
    };
  }
  function identity(value) {
    return value;
  }
  function stubFalse() {
    return false;
  }
  module.exports = merge;
});
var lodash_mergewith = createCommonjsModule(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var objectCtorString = funcToString2.call(Object);
  var reIsNative2 = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array = root2.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
  var Map2 = getNative2(root2, "Map"), nativeCreate2 = getNative2(Object, "create");
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function Hash2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index = assocIndexOf2(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq2(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assignValue2(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  var baseFor = createBaseFor();
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeysIn(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject2(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray2(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue2(object, key, newValue);
      }
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function getMapData2(map, key) {
    var data = map.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function isIndex2(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex2(index, object.length) : type == "string" && index in object) {
      return eq2(object[index], value);
    }
    return false;
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  var setToString = shortOut(baseSetToString);
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike2(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
  });
  function constant(value) {
    return function() {
      return value;
    };
  }
  function identity(value) {
    return value;
  }
  function stubFalse() {
    return false;
  }
  module.exports = mergeWith;
});
var useMessages = function(options) {
  var pubnub = usePubNub();
  var _a = (0, import_react.useState)(function() {
    var initial = {};
    options.channels.forEach(function(channel) {
      return initial[channel] = [];
    });
    return initial;
  }), messages = _a[0], setMessages = _a[1];
  var _b = (0, import_react.useState)(void 0), page = _b[0], setPage = _b[1];
  var _c = (0, import_react.useState)(false), fetchedAll = _c[0], setFetchedAll = _c[1];
  var _d = (0, import_react.useState)(), error = _d[0], setError = _d[1];
  var mandatoryOptions = {
    start: page
  };
  var mergedOptions = lodash_merge(options, mandatoryOptions);
  var command = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var response, newMessages, earliestMessageTimetokens, lastTimetoken, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            if (fetchedAll)
              return [2];
            return [4, pubnub.fetchMessages(mergedOptions)];
          case 1:
            response = _a2.sent();
            newMessages = lodash_mergewith({}, messages, response.channels, mergeMessageArray);
            earliestMessageTimetokens = Object.values(response.channels).flatMap(function(ary) {
              return ary[0];
            }).map(function(a) {
              return a.timetoken;
            });
            lastTimetoken = Math.min.apply(Math, earliestMessageTimetokens);
            setMessages(newMessages);
            setPage(lastTimetoken - 1);
            setFetchedAll(!Object.keys(response.channels).length);
            return [3, 3];
          case 2:
            e_1 = _a2.sent();
            setError(e_1);
            return [3, 3];
          case 3:
            return [2];
        }
      });
    });
  };
  var handleMessage = function(message) {
    try {
      setMessages(function(messages2) {
        var messagesClone = lodash_clonedeep(messages2);
        if (!messagesClone[message.channel])
          messagesClone[message.channel] = [];
        messagesClone[message.channel].push(message);
        return messagesClone;
      });
    } catch (e) {
      setError(e);
    }
  };
  var handleAction = function(action) {
    try {
      if (!messages[action.channel])
        return;
      setMessages(function(messages2) {
        var _a2, _b2;
        var channel = action.channel, event2 = action.event;
        var _c2 = action.data, type = _c2.type, value = _c2.value, actionTimetoken = _c2.actionTimetoken, messageTimetoken = _c2.messageTimetoken, uuid = _c2.uuid;
        var messagesClone = lodash_clonedeep(messages2);
        var message = messagesClone[channel].find(function(m) {
          return m.timetoken === messageTimetoken;
        });
        var actions = ((_b2 = (_a2 = message === null || message === void 0 ? void 0 : message.actions) === null || _a2 === void 0 ? void 0 : _a2[type]) === null || _b2 === void 0 ? void 0 : _b2[value]) || [];
        if (message && event2 === "added") {
          var newActions = __spreadArray(__spreadArray([], actions), [{ uuid, actionTimetoken }]);
          lodash_set(message, ["actions", type, value], newActions);
        }
        if (message && event2 === "removed") {
          var newActions = actions.filter(function(a) {
            return a.actionTimetoken !== actionTimetoken;
          });
          newActions.length ? lodash_set(message, ["actions", type, value], newActions) : delete message.actions[type][value];
        }
        return messagesClone;
      });
    } catch (e) {
      setError(e);
    }
  };
  var listener = (0, import_react.useRef)({
    message: handleMessage,
    messageAction: handleAction
  });
  (0, import_react.useEffect)(function() {
    command();
    pubnub.addListener(listener.current);
    return function() {
      pubnub.removeListener(listener.current);
    };
  }, [pubnub]);
  return [messages, command, error];
};
var mergeMessageArray = function(oldMessages, newMessages) {
  if (Array.isArray(oldMessages)) {
    return __spreadArray(__spreadArray([], oldMessages), newMessages).sort(function(a, b) {
      return a.timetoken - b.timetoken;
    });
  }
};
var usePresence = function(options) {
  if (options === void 0) {
    options = {};
  }
  var pubnub = usePubNub();
  var _a = (0, import_react.useState)({}), presence = _a[0], setPresence = _a[1];
  var _b = (0, import_react.useState)(), error = _b[0], setError = _b[1];
  var presenceValues = Object.values(presence);
  var total = presenceValues.map(function(ch) {
    return ch.occupancy;
  }).reduce(function(prev, cur) {
    return prev + cur;
  }, 0);
  var command = (0, import_react.useCallback)(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var response, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, pubnub.hereNow(options)];
          case 1:
            response = _a2.sent();
            setPresence(response.channels);
            return [3, 3];
          case 2:
            e_1 = _a2.sent();
            setError(e_1);
            return [3, 3];
          case 3:
            return [2];
        }
      });
    });
  }, [pubnub, JSON.stringify(options)]);
  var handlePresence = (0, import_react.useCallback)(function(event2) {
    setPresence(function(presence2) {
      var presenceClone = lodash_clonedeep(presence2);
      if (!presenceClone[event2.channel])
        presenceClone[event2.channel] = { name: event2.channel, occupancy: 0, occupants: [] };
      var channel = presenceClone[event2.channel];
      if (event2.action === "join") {
        if (!channel.hasOwnProperty("occupants"))
          channel.occupants = [];
        channel.occupancy = event2.occupancy;
        if (options.includeUUIDs !== false && channel.hasOwnProperty("occupants") && !channel.occupants.find(function(u) {
          return u.uuid == event2.uuid;
        })) {
          var state = event2.state, uuid = event2.uuid;
          channel.occupants.push({ state, uuid });
        }
      }
      if (["leave", "timeout"].includes(event2.action)) {
        channel.occupancy = event2.occupancy;
        if (options.includeUUIDs !== false && channel.hasOwnProperty("occupants") && channel.occupants.find(function(u) {
          return u.uuid == event2.uuid;
        })) {
          presenceClone[event2.channel].occupants = channel.occupants.filter(function(u) {
            return u.uuid !== event2.uuid;
          });
        }
      }
      return presenceClone;
    });
  }, [options.includeUUIDs]);
  (0, import_react.useEffect)(function() {
    pubnub.addListener({ presence: handlePresence });
  }, [handlePresence, pubnub]);
  (0, import_react.useEffect)(function() {
    setPresence({});
    setError(null);
    command();
  }, [command]);
  return [presence, command, total, error];
};
var useUser = function(options) {
  if (options === void 0) {
    options = {};
  }
  var pubnub = usePubNub();
  var _a = (0, import_react.useState)(null), user = _a[0], setUser = _a[1];
  var _b = (0, import_react.useState)(), error = _b[0], setError = _b[1];
  var command = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var response, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, pubnub.objects.getUUIDMetadata(options)];
          case 1:
            response = _a2.sent();
            setUser(response.data);
            return [3, 3];
          case 2:
            e_1 = _a2.sent();
            setError(e_1);
            return [3, 3];
          case 3:
            return [2];
        }
      });
    });
  };
  var handleObject = function(event2) {
    var message = event2.message;
    if (message.type !== "uuid")
      return;
    setUser(function(user2) {
      var userCopy = lodash_clonedeep(user2);
      if (message.data.id == user2.id) {
        Object.assign(userCopy, message.data);
      }
      return userCopy;
    });
  };
  (0, import_react.useEffect)(function() {
    pubnub.addListener({ objects: handleObject });
    command();
  }, []);
  return [user, error];
};
var useSubscribe = function(options) {
  if (options === void 0) {
    options = {};
  }
  var pubnub = usePubNub();
  var unsubscribe = function() {
    pubnub.unsubscribe(options);
  };
  (0, import_react.useEffect)(function() {
    options.channels = options.channels || [];
    options.channelGroups = options.channelGroups || [];
    var currentSubscriptions = pubnub.getSubscribedChannels() || [];
    var currentGroups = pubnub.getSubscribedChannelGroups() || [];
    var subscribeChannels = options.channels.filter(function(c) {
      return !currentSubscriptions.includes(c);
    });
    var unsubscribeChannels = currentSubscriptions.filter(function(c) {
      return !options.channels.includes(c);
    });
    var subscribeGroups = options.channelGroups.filter(function(c) {
      return !currentGroups.includes(c);
    });
    var unsubscribeGroups = currentGroups.filter(function(c) {
      return !options.channelGroups.includes(c);
    });
    if (subscribeChannels.length || subscribeGroups.length) {
      pubnub.subscribe({
        channels: subscribeChannels,
        channelGroups: subscribeGroups,
        withPresence: options.withPresence
      });
    }
    if (unsubscribeChannels.length || unsubscribeGroups.length) {
      pubnub.unsubscribe({
        channels: unsubscribeChannels,
        channelGroups: unsubscribeGroups
      });
    }
  }, [JSON.stringify(options.channels), JSON.stringify(options.channelGroups)]);
  return unsubscribe;
};
var useUsers = function(options) {
  if (options === void 0) {
    options = {};
  }
  var pubnub = usePubNub();
  var _a = (0, import_react.useState)([]), users = _a[0], setUsers = _a[1];
  var _b = (0, import_react.useState)(0), totalCount = _b[0], setTotalCount = _b[1];
  var _c = (0, import_react.useState)(""), page = _c[0], setPage = _c[1];
  var _d = (0, import_react.useState)(), error = _d[0], setError = _d[1];
  var paginatedOptions = lodash_merge({}, options, {
    page: { next: page },
    include: { totalCount: true }
  });
  var command = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var response_1, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            if (totalCount && users.length >= totalCount)
              return [2];
            return [4, pubnub.objects.getAllUUIDMetadata(paginatedOptions)];
          case 1:
            response_1 = _a2.sent();
            setUsers(function(users2) {
              return __spreadArray(__spreadArray([], users2), response_1.data);
            });
            setTotalCount(response_1.totalCount);
            setPage(response_1.next);
            return [3, 3];
          case 2:
            e_1 = _a2.sent();
            setError(e_1);
            return [3, 3];
          case 3:
            return [2];
        }
      });
    });
  };
  var handleObject = function(event2) {
    var message = event2.message;
    if (message.type !== "uuid")
      return;
    setUsers(function(users2) {
      var usersCopy = lodash_clonedeep(users2);
      var user = usersCopy.find(function(u) {
        return u.id === message.data.id;
      });
      if (user && message.event === "set") {
        Object.assign(user, message.data);
      }
      if (user && message.event === "delete") {
        usersCopy.splice(usersCopy.indexOf(user), 1);
      }
      return usersCopy;
    });
  };
  (0, import_react.useEffect)(function() {
    pubnub.addListener({ objects: handleObject });
    command();
  }, []);
  return [users, command, totalCount, error];
};
var useChannels = function(options) {
  if (options === void 0) {
    options = {};
  }
  var pubnub = usePubNub();
  var _a = (0, import_react.useState)([]), channels = _a[0], setChannels = _a[1];
  var _b = (0, import_react.useState)(""), page = _b[0], setPage = _b[1];
  var _c = (0, import_react.useState)(0), totalCount = _c[0], setTotalCount = _c[1];
  var _d = (0, import_react.useState)(), error = _d[0], setError = _d[1];
  var paginatedOptions = lodash_merge({}, options, {
    page: { next: page },
    include: { totalCount: true }
  });
  var command = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var response_1, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            if (totalCount && channels.length >= totalCount)
              return [2];
            return [4, pubnub.objects.getAllChannelMetadata(paginatedOptions)];
          case 1:
            response_1 = _a2.sent();
            setChannels(function(channels2) {
              return __spreadArray(__spreadArray([], channels2), response_1.data);
            });
            setTotalCount(response_1.totalCount);
            setPage(response_1.next);
            return [3, 3];
          case 2:
            e_1 = _a2.sent();
            setError(e_1);
            return [3, 3];
          case 3:
            return [2];
        }
      });
    });
  };
  var handleObject = function(event2) {
    var message = event2.message;
    if (message.type !== "channel")
      return;
    setChannels(function(channels2) {
      var channelsCopy = lodash_clonedeep(channels2);
      var channel = channelsCopy.find(function(ch) {
        return ch.id === event2.channel;
      });
      if (channel && message.event === "set") {
        Object.assign(channel, message.data);
      }
      if (channel && message.event === "delete") {
        channelsCopy.splice(channelsCopy.indexOf(channel), 1);
      }
      return channelsCopy;
    });
  };
  (0, import_react.useEffect)(function() {
    pubnub.addListener({ objects: handleObject });
    command();
  }, []);
  return [channels, command, totalCount, error];
};
var useChannelMembers = function(options) {
  var jsonOptions = JSON.stringify(options);
  var pubnub = usePubNub();
  var _a = (0, import_react.useState)([]), members = _a[0], setMembers = _a[1];
  var _b = (0, import_react.useState)(0), totalCount = _b[0], setTotalCount = _b[1];
  var _c = (0, import_react.useState)(""), page = _c[0], setPage = _c[1];
  var _d = (0, import_react.useState)(), error = _d[0], setError = _d[1];
  var _e = (0, import_react.useState)(true), doFetch = _e[0], setDoFetch = _e[1];
  var _f = (0, import_react.useState)(false), fetching = _f[0], setFetching = _f[1];
  var paginatedOptions = (0, import_react.useMemo)(function() {
    return lodash_merge({}, JSON.parse(jsonOptions), {
      page: { next: page },
      include: { totalCount: true }
    });
  }, [page, jsonOptions]);
  var resetHook = function() {
    setMembers([]);
    setTotalCount(0);
    setPage("");
    setError(void 0);
    setDoFetch(true);
  };
  var fetchPage = (0, import_react.useCallback)(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var response_1, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            setDoFetch(false);
            setFetching(true);
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, 4, 5]);
            if (totalCount && members.length >= totalCount)
              return [2];
            return [4, pubnub.objects.getChannelMembers(paginatedOptions)];
          case 2:
            response_1 = _a2.sent();
            setMembers(function(members2) {
              return __spreadArray(__spreadArray([], members2), response_1.data.map(function(m) {
                return m.uuid;
              }));
            });
            setTotalCount(response_1.totalCount);
            setPage(response_1.next);
            return [3, 5];
          case 3:
            e_1 = _a2.sent();
            setError(e_1);
            return [3, 5];
          case 4:
            setFetching(false);
            return [7];
          case 5:
            return [2];
        }
      });
    });
  }, [pubnub, paginatedOptions, members.length, totalCount]);
  var handleObject = function(event2) {
    var message = event2.message;
    if (message.type !== "membership")
      return;
    setMembers(function(members2) {
      var membersCopy = lodash_clonedeep(members2);
      var member = membersCopy.find(function(u) {
        return u.id === message.data.uuid.id;
      });
      if (message.data.channel !== options.channel)
        return membersCopy;
      if (member && message.event === "delete") {
        membersCopy.splice(membersCopy.indexOf(member), 1);
      }
      return membersCopy;
    });
  };
  (0, import_react.useEffect)(function() {
    pubnub.addListener({ objects: handleObject });
  }, [pubnub]);
  (0, import_react.useEffect)(function() {
    resetHook();
  }, [jsonOptions]);
  (0, import_react.useEffect)(function() {
    setMembers([]);
    setTotalCount(0);
    setPage("");
  }, [options.channel]);
  (0, import_react.useEffect)(function() {
    if (doFetch && !fetching)
      fetchPage();
  }, [doFetch, fetching, fetchPage]);
  return [members, fetchPage, resetHook, totalCount, error];
};
var useUserMemberships = function(options) {
  if (options === void 0) {
    options = {};
  }
  var jsonOptions = JSON.stringify(options);
  var pubnub = usePubNub();
  var _a = (0, import_react.useState)([]), channels = _a[0], setChannels = _a[1];
  var _b = (0, import_react.useState)(0), totalCount = _b[0], setTotalCount = _b[1];
  var _c = (0, import_react.useState)(""), page = _c[0], setPage = _c[1];
  var _d = (0, import_react.useState)(), error = _d[0], setError = _d[1];
  var _e = (0, import_react.useState)(true), doFetch = _e[0], setDoFetch = _e[1];
  var _f = (0, import_react.useState)(false), fetching = _f[0], setFetching = _f[1];
  var paginatedOptions = (0, import_react.useMemo)(function() {
    return lodash_merge({}, JSON.parse(jsonOptions), {
      page: { next: page },
      include: { totalCount: true }
    });
  }, [page, jsonOptions]);
  var resetHook = function() {
    setChannels([]);
    setTotalCount(0);
    setPage("");
    setError(void 0);
    setDoFetch(true);
  };
  var fetchPage = (0, import_react.useCallback)(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var response_1, e_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            setDoFetch(false);
            setFetching(true);
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, 4, 5]);
            if (totalCount && channels.length >= totalCount)
              return [2];
            return [4, pubnub.objects.getMemberships(paginatedOptions)];
          case 2:
            response_1 = _a2.sent();
            setChannels(function(channels2) {
              return __spreadArray(__spreadArray([], channels2), response_1.data.map(function(m) {
                return m.channel;
              }));
            });
            setTotalCount(response_1.totalCount);
            setPage(response_1.next);
            return [3, 5];
          case 3:
            e_1 = _a2.sent();
            setError(e_1);
            return [3, 5];
          case 4:
            setFetching(false);
            return [7];
          case 5:
            return [2];
        }
      });
    });
  }, [pubnub, paginatedOptions, channels.length, totalCount]);
  var handleObject = function(event2) {
    var message = event2.message;
    if (message.type !== "membership")
      return;
    setChannels(function(channels2) {
      var channelsCopy = lodash_clonedeep(channels2);
      var channel = channelsCopy.find(function(u) {
        return u.id === message.data.channel.id;
      });
      var currentUuid = options.uuid || pubnub.getUUID();
      if (message.data.uuid.id !== currentUuid)
        return channelsCopy;
      if (channel && message.event === "delete") {
        channelsCopy.splice(channelsCopy.indexOf(channel), 1);
      }
      return channelsCopy;
    });
  };
  (0, import_react.useEffect)(function() {
    pubnub.addListener({ objects: handleObject });
  }, [pubnub]);
  (0, import_react.useEffect)(function() {
    resetHook();
  }, [jsonOptions]);
  (0, import_react.useEffect)(function() {
    if (doFetch && !fetching)
      fetchPage();
  }, [doFetch, fetching, fetchPage]);
  return [channels, fetchPage, resetHook, totalCount, error];
};
export {
  ChannelList,
  Chat,
  ChatInternal,
  MemberList,
  MessageInput,
  MessageList,
  TypingIndicator,
  getNameInitials,
  getPredefinedColor,
  isFileMessage,
  useChannelMembers,
  useChannels,
  useMessages,
  useOuterClick,
  usePresence,
  useSubscribe,
  useUser,
  useUserMemberships,
  useUsers
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=@pubnub_react-chat-components.js.map
